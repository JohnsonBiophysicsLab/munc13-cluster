import os
import math
import numpy as np
import pandas as pd
import scipy.integrate
import matplotlib.pyplot as plt
import time
import seaborn as sns
from matplotlib.patches import Patch

# DEAP imports
from deap import base, creator, tools, algorithms

# Multiprocessing for parallel execution
import multiprocessing
from concurrent.futures import ProcessPoolExecutor

import warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)


class Munc13:
    def __init__(self, parameter_ranges, params, mode=0, t_max_pre=50000, t_max=30.0, experiment_dt=0.5):
        """
        A model class for simulating Munc13 dynamics (pre- and post-stimulation).
        
        :param parameter_ranges: dict with min/max for each parameter to be optimized
        :param params: list/array of parameter names (strings) in the order they appear in candidate solutions
        :param mode: an integer to select among multiple evaluation modes
        """
        self.n_params = len(params)
        self.params_to_optimize = params
        self.parameter_ranges = parameter_ranges
        self.t_max = t_max
        self.t_max_pre = t_max_pre
        self.h = 0.01  # 3D to 2D length scale in um
        VAratio = 1.9  # conversion factor
        self.Atotal = 1 / 1.176        # (1/cluster density) area per cluster in um^2, pre-stim (determined by experimental cluster density)
        self.Acluster = 0.01862     # cluster area, pre-stim
        self.V = self.Atotal * VAratio
        self.gamma = self.V / (self.Atotal * self.h)

        self.AtotalDense = 1 / 1.675   # (1/cluster density) area per cluster in um^2, post-stim (determined by experimental cluster density)
        self.AclusterDense = 0.02087 # cluster area, post-stim
        self.VDense = self.AtotalDense * VAratio
        self.gammaDense = self.VDense / (self.AtotalDense * self.h)

        self.densIncrease = 3

        # diffusion constants
        self.D_exp_pre = 0.04255
        self.D_exp_pre_sem = 0.003675
        self.D_model_pre = None

        self.D_exp_post = 0.035611
        self.D_exp_post_sem = 0.002845
        self.D_model_post = None

        self.D_exp_DC2A_pre = 0.07652157
        self.D_exp_DC2A_pre_sem = 0.003385
        self.D_model_DC2A_pre = None

        self.D_exp_DC2A_post = 0.080462
        self.D_exp_DC2A_post_sem = 0.00273
        self.D_model_DC2A_post = None

        self.D_exp_shRIM_pre = 0.04514325
        self.D_exp_shRIM_pre_sem = 0.006545
        self.D_model_shRIM_pre = None

        self.D_exp_shRIM_post = 0.033447
        self.D_exp_shRIM_post_sem = 0.005401
        self.D_model_shRIM_post = None

        self.D_exp_DC2B_pre = 0.04692072
        self.D_exp_DC2B_pre_sem = 0.003362
        self.D_model_DC2B_pre = None

        self.D_exp_DC2B_post = 0.040632
        self.D_exp_DC2B_post_sem = 0.003063
        self.D_model_DC2B_post = None

        self.D_model_endogenous_pre = None
        self.D_model_endogenous_post = None

        self.bestSolution = None
        self.filteredSolutions = None

        self.D_munc = None
        self.D_R = None

        self.final_d_pre = None
        self.final_d_post = None

        # Experimental data setup, NOT USED
        targetIncrease = 15.1
        targetIncreasePost = 11.4
        n_time_points = int(self.t_max / experiment_dt)
        n_time_points_pre = int(self.t_max_pre / experiment_dt)
        self.timePoints = [i * experiment_dt for i in range(n_time_points + 1)]
        self.timePointsPre = [i * experiment_dt for i in range(n_time_points_pre + 1)]

        # Load experimental data
        self.expdata = pd.read_table(
            os.path.join("../data/wt_result_nonorm95.txt"),
            header=None, sep=r"\s+",
            names=["time", "expInt", "expSEM"]
        )
        self.expTime = self.expdata.time
        N = len(self.expdata)

        # Adjust intensities for modeling
        self.delIntensity = (self.expdata.expInt[N - 1] - targetIncrease * self.expdata.expInt[0]) / (1.0 - targetIncrease)
        self.delIntensityPost = (self.expdata.expInt[N - 1] - targetIncreasePost * self.expdata.expInt[0]) / (1.0 - targetIncreasePost)

        self.mode = mode
        self.modes = [self.eval_both]

        # Minimum threshold for a "viable" solution
        self.threshold = -500


    # -----------------------------
    #     ODE system definitions
    # -----------------------------
    def dimerOde(self, t, y, params):
        """
        ODE for pre-equilibration without cluster.
        y = [ S, R, M, D ]
        """
        # y[0] = S
        # y[1] = R
        # y[2] = M
        # y[3] = D
        kfsr = params[0]
        krsr = params[1]
        gamma = params[2]
        kfmm = params[3]
        krmm = params[4]
        dylist = []
        dylist.append(-kfsr*y[0]*y[1]+krsr*y[2])
        dylist.append(-kfsr*y[0]*y[1]+krsr*y[2])
        dylist.append(+kfsr*y[0]*y[1]-krsr*y[2]-gamma*kfmm*y[2]*y[2]+krmm*y[3]-gamma*kfmm*y[2]*y[2]+krmm*y[3])
        dylist.append(+gamma*kfmm*y[2]*y[2]-krmm*y[3])
        return np.array(dylist)


    def munc13Ode(self, t, y, params):
        """
        Munc13 ODE model.

        y[0]  = S, Munc13 in solution
        y[1]  = R, General recruiter on the membrane
        y[2]  = M, Munc13 on the membrane (out of the cluster)
        y[3]  = D, Munc13 dimer on the membrane (out of the cluster)
        y[4]  = X, Recruiter in the cluster
        y[5]  = W, Munc13 in the cluster recruited from 3D
        y[6]  = Y, Recruiter in the cluster converted from X
        y[7]  = C, Munc13 in the cluster recruited from 2D
        y[8]  = Z, Recruiter in the cluster converted from Y

        Reaction equations:
            S + R <-> M, kfsr, krsr
            M + M <-> D, gamma*kfmm, krmm
            S + X -> W + Y, kfc
            M + X -> C + Y, gamma*kfc
            D + X -> C + C + Y + Y - X, 2*gamma*kfc
            S + Y -> W + Z, kfc
            M + Y -> C + Z, gamma*kfc
            D + Y -> C + C + Z + Z - Y, 2*gamma*kfc
            S + Z -> W, kfc
            M + Z -> C, gamma*kfc
            D + Z -> C + C - Z, 2*gamma*kfc
        """
        kfsr = params[0]
        krsr = params[1]
        gamma = params[2]
        kfmm = params[3]
        krmm = params[4]
        kfc = params[5]
        dylist = []
        dylist.append(-kfsr*y[0]*y[1]+krsr*y[2]-kfc*y[0]*y[4]-kfc*y[0]*y[6]-kfc*y[0]*y[8])
        dylist.append(-kfsr*y[0]*y[1]+krsr*y[2])
        dylist.append(+kfsr*y[0]*y[1]-krsr*y[2]-gamma*kfmm*y[2]*y[2]+krmm*y[3]-gamma*kfmm*y[2]*y[2]+krmm*y[3]-gamma*kfc*y[2]*y[4]-gamma*kfc*y[2]*y[6]-gamma*kfc*y[2]*y[8])
        dylist.append(+gamma*kfmm*y[2]*y[2]-krmm*y[3]-2*gamma*kfc*y[3]*y[4]-2*gamma*kfc*y[3]*y[6]-2*gamma*kfc*y[3]*y[8])
        dylist.append(-kfc*y[0]*y[4]-gamma*kfc*y[2]*y[4]-2*gamma*kfc*y[3]*y[4]-2*gamma*kfc*1*y[3]*y[4])
        dylist.append(+kfc*y[0]*y[4]+kfc*y[0]*y[6]+kfc*y[0]*y[8])
        dylist.append(+kfc*y[0]*y[4]+gamma*kfc*y[2]*y[4]+2*gamma*kfc*y[3]*y[4]+2*gamma*kfc*y[3]*y[4]-kfc*y[0]*y[6]-gamma*kfc*y[2]*y[6]-2*gamma*kfc*y[3]*y[6]-2*gamma*kfc*1*y[3]*y[6])
        dylist.append(+gamma*kfc*y[2]*y[4]+2*gamma*kfc*y[3]*y[4]+2*gamma*kfc*y[3]*y[4]+gamma*kfc*y[2]*y[6]+2*gamma*kfc*y[3]*y[6]+2*gamma*kfc*y[3]*y[6]+gamma*kfc*y[2]*y[8]+2*gamma*kfc*y[3]*y[8]+2*gamma*kfc*y[3]*y[8])
        dylist.append(+kfc*y[0]*y[6]+gamma*kfc*y[2]*y[6]+2*gamma*kfc*y[3]*y[6]+2*gamma*kfc*y[3]*y[6]-kfc*y[0]*y[8]-gamma*kfc*y[2]*y[8]-2*gamma*kfc*y[3]*y[8]-2*gamma*kfc*1*y[3]*y[8])
        return np.array(dylist)


    # ------------------------------------------------------
    #        Utilities to compute Munc13 on cluster/membrane
    # ------------------------------------------------------
    def calculate_munc13(self, copies):
        """
        Munc13 in cluster (copies/um^2) = C/Acluster
        Munc13 on the membrane but not in cluster (copies/um^2) = (M + 2*D)/Atotal
        """
        mc3D = copies[5] / self.Acluster
        mc2D = copies[7] / self.Acluster
        md = (copies[2] + 2 * copies[3]) / self.Atotal
        return mc3D, mc2D, md


    def calculate_munc13_post(self, copies):
        """
        Same idea but for post-stimulation geometry (AclusterDense, AtotalDense).
        """
        mc3D = copies[5] / self.AclusterDense
        mc2D = copies[7] / self.AclusterDense
        md = (copies[2] + 2 * copies[3]) / self.AtotalDense
        return mc3D, mc2D, md


    def get_cluster_time_series(self, Y, post=False):
        """
        Return Munc13 copy number in cluster over time, per um^2.
        Y: ODE solution
        """
        copies = Y * (self.VDense if post else self.V) * 602
        mc = (copies[5] + copies[7]) / (self.AclusterDense if post else self.Acluster)
        md = (copies[2] + 2 * copies[3]) / (self.AtotalDense if post else self.Atotal)
        return mc, md


    def get_simulated_fold_change(self, mc, md):
        """
        Returns fold increase in cluster copy number
        """
        c0 = mc[0] + md[0]
        cf = mc[-1] + md[-1]
        return cf / c0


    def compute_background_from_target_increase(self, target_increase):
        """
        Compute background (delta) such that:
            (I_final - delta) / (I_0 - delta) = target_increase
        """
        I0 = self.expdata.expInt.iloc[0]
        If = self.expdata.expInt.iloc[-1]
        delta = (If - target_increase * I0) / (1.0 - target_increase)
        return delta


    # --------------------------------------------
    #          Cost (Chi) and viability checks
    # --------------------------------------------
    def costChi_pre(self, Y):
        """
        Compute a chi-square-like cost for the "pre" data.
        """
        mc, md = self.get_cluster_time_series(Y, False)
        fold_increase = self.get_simulated_fold_change(mc, md)
        delta = self.compute_background_from_target_increase(fold_increase)

        relInt = (self.expdata.expInt - delta) / (self.expdata.expInt[0] - delta)
        sem = self.expdata.expSEM / (self.expdata.expInt[0] - delta)

        copies = Y * self.V * 602
        mc3D, mc2D, md = self.calculate_munc13(copies)
        mc = mc3D + mc2D
        intensRatio = mc + md
        intensRatio /= md[0] if md[0] != 0 else 1.0

        nPt = len(relInt)
        nPsol = len(mc)

        if nPsol < nPt:
            # Not enough solution points -> penalty
            return [2 * self.threshold]

        # Sum of (data-model)^2 / sem^2
        ssum = 0
        for i in range(nPt):
            if sem[i] == 0:
                continue
            df = relInt[i] - intensRatio[i]
            ssum += df * df / (sem[i] * sem[i])

        y = 10 * ((intensRatio[-1] - intensRatio[int(nPt / 3 * 2)]))**2
        ssum += y

        c = mc[-1] * self.Acluster
        z = 0 * ((c - 30)/30.0)**2
        ssum += z

        return [-ssum]


    def costChi_post(self, Y):
        """
        Compute a chi-square-like cost for the "post" data.
        """
        mc, md = self.get_cluster_time_series(Y, True)
        fold_increase = self.get_simulated_fold_change(mc, md)
        delta = self.compute_background_from_target_increase(fold_increase)

        relInt = (self.expdata.expInt - delta) / (self.expdata.expInt[0] - delta)
        sem = self.expdata.expSEM / (self.expdata.expInt[0] - delta)

        copies = Y * self.VDense * 602
        mc3D, mc2D, md = self.calculate_munc13_post(copies)
        mc = mc3D + mc2D
        intensRatio = mc + md
        intensRatio /= md[0] if md[0] != 0 else 1.0

        nPt = len(relInt)
        nPsol = len(mc)
        if nPsol < nPt:
            return [2 * self.threshold]

        ssum = 0
        for i in range(nPt):
            if sem[i] == 0:
                continue
            df = relInt[i] - intensRatio[i]
            ssum += df * df / (sem[i] * sem[i])

        y = 10 * ((intensRatio[-1] - intensRatio[int(nPt / 3 * 2)]))**2
        ssum += y

        c = mc[-1] * self.AclusterDense
        z = 0 * ((c - 33)/33.0)**2
        ssum += z

        return [-ssum]


    def costChiDiffusion(self, Dpre, Dpost):
        """
        Compute a chi-square-like cost for the diffusion constants.
        """
        D_exp_pre = self.D_exp_pre # this the experimental measured diffusion constant for NO STIM (also named pre stim)
        D_exp_post = self.D_exp_post # experimental diffusion constant for STIM (post stim)
        ratio_pre_post = D_exp_pre / D_exp_post

        # Calculate differences
        diff_pre = (Dpre - D_exp_pre) ** 2
        diff_post = (Dpost - D_exp_post) ** 2
        ratio_diff = (Dpre / Dpost - ratio_pre_post) ** 2

        # Weight prefactors to normalize the terms
        # Normalize by the square of expected values to make terms dimensionless and comparable
        weight_pre = 50.0 / (D_exp_pre ** 2)
        weight_post = 50.0 / (D_exp_post ** 2)
        weight_ratio = 50.0 / (ratio_pre_post ** 2)

        sum_diff = weight_pre * diff_pre + weight_post * diff_post + weight_ratio * ratio_diff
        return [-sum_diff]
    
    
    def costChiDiffusionDC2A(self, Dpre, Dpost):
        """
        Compute a chi-square-like cost for the diffusion constants.
        """
        D_exp_pre = self.D_exp_DC2A_pre
        D_exp_post = self.D_exp_DC2A_post
        ratio_pre_post = D_exp_pre / D_exp_post

        # Calculate differences
        diff_pre = (Dpre - D_exp_pre) ** 2
        diff_post = (Dpost - D_exp_post) ** 2
        ratio_diff = (Dpre / Dpost - ratio_pre_post) ** 2

        # Weight prefactors to normalize the terms
        # Normalize by the square of expected values to make terms dimensionless and comparable
        weight_pre = 50.0 / (D_exp_pre ** 2)
        weight_post = 50.0 / (D_exp_post ** 2)
        weight_ratio = 50.0 / (ratio_pre_post ** 2)

        sum_diff = weight_pre * diff_pre + weight_post * diff_post + weight_ratio * ratio_diff
        return [-sum_diff]
    
    def costChiDiffusionDC2B(self, Dpre, Dpost):
        """
        Compute a chi-square-like cost for the diffusion constants.
        """
        D_exp_pre = self.D_exp_DC2B_pre
        D_exp_post = self.D_exp_DC2B_post
        ratio_pre_post = D_exp_pre / D_exp_post

        # Calculate differences
        diff_pre = (Dpre - D_exp_pre) ** 2
        diff_post = (Dpost - D_exp_post) ** 2
        ratio_diff = (Dpre / Dpost - ratio_pre_post) ** 2

        # Weight prefactors to normalize the terms
        # Normalize by the square of expected values to make terms dimensionless and comparable
        weight_pre = 50.0 / (D_exp_pre ** 2)
        weight_post = 50.0 / (D_exp_post ** 2)
        weight_ratio = 50.0 / (ratio_pre_post ** 2)

        sum_diff = weight_pre * diff_pre + weight_post * diff_post + weight_ratio * ratio_diff
        return [-sum_diff]
    
    def costChiDiffusionshRIM(self, Dpre, Dpost):
        """
        Compute a chi-square-like cost for the diffusion constants.
        """
        D_exp_pre = self.D_exp_shRIM_pre
        D_exp_post = self.D_exp_shRIM_post
        ratio_pre_post = D_exp_pre / D_exp_post

        # Calculate differences
        diff_pre = (Dpre - D_exp_pre) ** 2
        diff_post = (Dpost - D_exp_post) ** 2
        ratio_diff = (Dpre / Dpost - ratio_pre_post) ** 2

        # Weight prefactors to normalize the terms
        # Normalize by the square of expected values to make terms dimensionless and comparable
        weight_pre = 50.0 / (D_exp_pre ** 2)
        weight_post = 50.0 / (D_exp_post ** 2)
        weight_ratio = 50.0 / (ratio_pre_post ** 2)

        sum_diff = weight_pre * diff_pre + weight_post * diff_post + weight_ratio * ratio_diff
        return [-sum_diff]


    def isViableFitness(self, fit):
        return fit >= self.threshold


    def isViable(self, point):
        fitness = self.eval_both(point)
        return self.isViableFitness(fitness[0])


    # ---------------------------------------------------
    #   Main evaluation: combine pre and post conditions
    # ---------------------------------------------------
    def eval_both(self, candidate):
        """
        Evaluate the candidate solution on both pre- and post-stim conditions.
        """
        solutionPre, solutionPost, _, _, Dpre, Dpost = self.simulate(candidate)

        # Chi from pre
        chiPre = self.costChi_pre(solutionPre)
        # Chi from post
        chiPost = self.costChi_post(solutionPost)

        chiTotal = chiPre[0] + chiPost[0]

        # Additional penalty for matching the ~3x ratio of munc13 density on the membrane
        copiesPre = solutionPre * self.V * 602
        mcPre3D, mcPre2D, mrPre = self.calculate_munc13(copiesPre)
        mcPre = mcPre3D + mcPre2D
        membraneMuncPre = mcPre * self.Acluster + mrPre * self.Atotal
        clusterMuncPre = mcPre * self.Acluster + mrPre * self.Acluster
        ratioClusterPre = np.mean(clusterMuncPre / membraneMuncPre)
        densityPre = membraneMuncPre / self.Atotal

        copiesPost = solutionPost * self.VDense * 602
        mcPost3D, mcPost2D, mrPost = self.calculate_munc13_post(copiesPost)
        mcPost = mcPost3D + mcPost2D
        membraneMuncPost = mcPost * self.AclusterDense + mrPost * self.AtotalDense
        clusterMuncPost = mcPost * self.AclusterDense + mrPost * self.AclusterDense
        ratioClusterPost = np.mean(clusterMuncPost / membraneMuncPost)
        densityPost = membraneMuncPost / self.AtotalDense

        ratio = densityPost / densityPre
        mean_ratio = np.mean(ratio)
        costRatio = -((mean_ratio - self.densIncrease)/self.densIncrease) ** 2
        fracRatio = -((ratioClusterPre - 0.4)/0.4) ** 2 - ((ratioClusterPost - 0.4)/0.4) ** 2

        chiTotal += (150.0 * costRatio + 0.0 * fracRatio)

        # diffusion constants chi
        chiDiffusion = 250*self.costChiDiffusion(Dpre, Dpost)

        chiTotal += chiDiffusion[0]
        
        # diffusion constants of mutant chi
        candidate_dc2a = list(candidate)
        candidate_dc2a[3] = 0
        _, _, _, _, DpreDC2A, DpostDC2A = self.simulate(candidate_dc2a)
        
        chiDiffusionDC2A = 250*self.costChiDiffusionDC2A(DpreDC2A, DpostDC2A)
        
        chiTotal += chiDiffusionDC2A[0]
        
        candidate_shRIM = list(candidate)
        candidate_shRIM[3] *= 2
        _, _, _, _, DpreshRIM, DpostshRIM = self.simulate(candidate_shRIM)
        
        chiDiffusionshRIM = 250*self.costChiDiffusionshRIM(DpreshRIM, DpostshRIM)
        
        chiTotal += chiDiffusionshRIM[0]
        
        candidate_dc2b = list(candidate)
        candidate_dc2b[0] *= 0.5
        _, _, _, _, DpreDC2B, DpostDC2B = self.simulate(candidate_dc2b)
        
        chiDiffusionDC2B = 250*self.costChiDiffusionDC2B(DpreDC2B, DpostDC2B)
        
        chiTotal += chiDiffusionDC2B[0]

        return [chiTotal]


    # -----------------------------------------
    #      ODE simulation (pre/post)
    # -----------------------------------------
    def simulate_pre(self, candidate):
        """
        1) Pre-equilibration with a simpler ODE (dimerOde)
        2) Then feed final state into the full munc13Ode
        """
        kfsr=candidate[0] #form SR
        krsr=candidate[1] #dissociate SR
        kfmm=candidate[3] #form D
        krmm=candidate[4] #dissociate D
        kfc=candidate[5] #form C
        S0=candidate[7] #initial Solution Munc13 (S), uM
        R0=candidate[8] #initial R, /um^2
        D1=candidate[9] #Monomer (M) diffusion constant on membrane, um^2/s
        D2=candidate[9] / candidate[10] #Dimer (D) diffusion constant on membrane, um^2/s
        X0 = candidate[11] / self.Acluster
        # convert to uM
        R0 = R0*self.Atotal/self.V/602.0 
        X0 = X0*self.Acluster/self.V/602.0

        rateParams=np.array([kfsr, krsr, self.gamma, kfmm, krmm])
        initValues=np.array([S0,R0,0,0])
        solution_pre = scipy.integrate.solve_ivp(fun=self.dimerOde, method='BDF', t_span=(0, self.t_max_pre), y0=initValues, t_eval=self.timePointsPre, args=(rateParams,), rtol=1e-7, atol=1e-9)
        solution = solution_pre.y
        solution = solution[:, -1]

        rateParams = np.array([kfsr,krsr,self.gamma,kfmm,krmm,kfc])
        initValues = np.array([solution[0],solution[1],solution[2],solution[3],X0,0,0,0,0])
        solution = scipy.integrate.solve_ivp(fun=self.munc13Ode, method='BDF', t_span=(0, self.t_max), y0=initValues, t_eval=self.timePoints, args=(rateParams,), rtol=1e-7, atol=1e-9)

        D = self.calc_diffusion(D1, D2, solution.y)

        return solution.y, solution_pre.y, D


    def simulate_post(self, candidate):
        """
        Same idea but uses post-stim geometry and possibly different parameters.
        """
        kfsr=candidate[0] #form SR
        krsr=candidate[2] #dissociate SR
        kfmm=candidate[3] #form D
        krmm=candidate[4] #dissociate D
        kfc=candidate[6] #form C
        S0=candidate[7] #initial Solution Munc13 (S), uM
        R0=candidate[8] #initial R, /um^2
        D1=candidate[9] #Monomer (M) diffusion constant on membrane, um^2/s
        D2=candidate[9] / candidate[10] #Dimer (D) diffusion constant on membrane, um^2/s
        X0 = candidate[11] / self.Acluster
        # convert to uM
        R0 = R0*self.AtotalDense/self.VDense/602.0 
        X0 = X0*self.AclusterDense/self.VDense/602.0

        rateParams=np.array([kfsr, krsr, self.gamma, kfmm, krmm])
        initValues=np.array([S0,R0,0,0])
        solution_pre = scipy.integrate.solve_ivp(fun=self.dimerOde, method='BDF', t_span=(0, self.t_max_pre), y0=initValues, t_eval=self.timePointsPre, args=(rateParams,), rtol=1e-7, atol=1e-9)
        solution = solution_pre.y
        solution = solution[:, -1]

        rateParams = np.array([kfsr,krsr,self.gamma,kfmm,krmm,kfc])
        initValues = np.array([solution[0],solution[1],solution[2],solution[3],X0,0,0,0,0])
        solution = scipy.integrate.solve_ivp(fun=self.munc13Ode, method='BDF', t_span=(0, self.t_max), y0=initValues, t_eval=self.timePoints, args=(rateParams,), rtol=1e-7, atol=1e-9)

        D = self.calc_diffusion(D1, D2, solution.y)

        return solution.y, solution_pre.y, D


    def simulate(self, candidate):
        """
        Wrapper to run both pre- and post-stimulation solvers.
        """
        solutionPre, simulationPreEq, Dpre = self.simulate_pre(candidate)
        solutionPost, simulationPostEq, Dpost = self.simulate_post(candidate)
        return [solutionPre, solutionPost, simulationPreEq, simulationPostEq, Dpre, Dpost]


    def calc_diffusion(self, D1, D2, solution):
        """Calculate the average of Munc13 on membrane diffusion constants"""
        D_average = (solution[2] * D1 + 2*solution[3] * D2) / (solution[2] + 2*solution[3] + solution[5] + solution[7])

        return D_average[-1]


    def calculate_results(self, solution):
        solutionPre, solutionPost, solutionPreEq, solutionPostEq,_,_ = self.simulate(solution)
        copies = solutionPre * self.V * 602
        mc3D, mc2D, mr = self.calculate_munc13(copies)
        intensRatio = np.divide((mc3D+mc2D) + mr, mr[0])
        pre = (mc3D+mc2D) * self.Acluster + mr * self.Atotal
        preCluster = (mc3D+mc2D) * self.Acluster + mr * self.Acluster
        preCluster3D = mc3D * self.Acluster
        preCluster2D = mc2D * self.Acluster
        preClusterR = mr * self.Acluster
        copiesPost = solutionPost * self.VDense * 602
        mcPost3D, mcPost2D, mrPost = self.calculate_munc13_post(copiesPost)
        intensRatioPost = np.divide((mcPost3D+mcPost2D) + mrPost, mrPost[0])
        post = (mcPost3D+mcPost2D) * self.AclusterDense + mrPost * self.AtotalDense
        postCluster = (mcPost3D+mcPost2D) * self.AclusterDense + mrPost * self.AclusterDense
        postCluster3D = mcPost3D * self.AclusterDense
        postCluster2D = mcPost2D * self.AclusterDense
        postClusterR = mrPost * self.AclusterDense
        
        # pre eq simulation without cluster recruiter
        copies = solutionPreEq * self.V * 602
        preEq = copies[2] + 2 * copies[3]
        
        copies = solutionPostEq * self.VDense * 602
        postEq = copies[2] + 2 * copies[3]

        return intensRatio, intensRatioPost, preCluster, postCluster, pre, post, preEq, postEq, preCluster3D, preCluster2D, preClusterR, postCluster3D, postCluster2D, postClusterR


    def calc_diffusion_dilute(self, D1, D2, solution):
        """Calculate the average of Munc13 in dilute diffusion constants"""
        D_average = (solution[2] * D1 + 2 * solution[3] * D2) / (solution[2] + 2 * solution[3])
        percentages_M = (solution[2]) / (solution[2] + 2 * solution[3])
        percentages_D = (2*solution[3]) / (solution[2] + 2 * solution[3])
        # print(f"Percentages of Munc13 in M: {percentages_M[-1]}, in D: {percentages_D[-1]}")

        return D_average[-1]


    def calc_percentages_cluster(self, solution):
        """Calcualte the percentage of Munc13 copies in cluster"""
        P_average = (solution[5] + solution[7]) / (solution[2] + 2 * solution[3] + solution[5] + solution[7])

        return P_average[-1]

    def calc_populations(self, solution):
        P_cluster = (solution[5] + solution[7]) / (solution[2] + 2 * solution[3] + solution[5] + solution[7])
        P_monomer = (solution[2]) / (solution[2] + 2 * solution[3] + solution[5] + solution[7])
        P_dimer = (2 * solution[3]) / (solution[2] + 2 * solution[3] + solution[5] + solution[7])

        return P_monomer[-1], P_dimer[-1], P_cluster[-1]
    
    def calc_3D_2D_percentages_cluster(self, solution):
        """Calcualte the percentage of Munc13 copies in cluster from 3D or 2D"""
        P_3D_average = (solution[5]) / (solution[5] + solution[7])
        P_2D_average = (solution[7]) / (solution[5] + solution[7])

        return P_3D_average[-1], P_2D_average[-1]


    def filter_and_store_solutions(self, best=100, totalTime=30.0, dt=0.1):
        np.random.seed(42)
        self.t_max = totalTime
        n_time_points = int(totalTime / dt)
        self.timePoints = [i * dt for i in range(n_time_points + 1)]
    
        df = pd.read_csv("../data/optimizedParms.txt", sep=",", engine="python")
        df.columns = df.columns.str.strip()
        df = df.sort_values(by="Rank")
    
        param_cols = [col for col in df.columns if col not in ["Rank", "Fitness"]]
    
        qualified = []
        for _, row in df.iterrows():
            param_vector = [float(row[col]) for col in param_cols]
            intensRatio, intensRatioPost, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(param_vector)
            tmp = np.mean(post/pre)
            # print("Average munc13 on membrane, NOSTIM/STIM: ", tmp)
            if True:#preCluster[-1] >= 30 and tmp > 1.5:
                qualified.append(param_vector)
                if len(qualified) == best:
                    break
                else:
                    if len(qualified) % 10 == 0:
                        # print(f"{len(qualified)} solutions found")
                        pass
    
        self.filteredSolutions = qualified
        self.bestSolution = qualified[0] if qualified else None

    def plot_total_recruitment_wt(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, pre / self.Atotal, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, post / self.AtotalDense, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A density on membrane\n(copies/$\mu$m$^2$)")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 600)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_total_recruitment_wt.svg") 
        fig.savefig("../fig/fig_total_recruitment_wt.png", dpi=dpi) 
        plt.show()
        
    def plot_cluster_recruitment_wt(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, preCluster, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, postCluster, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A copies in cluster")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 50)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_cluster_recruitment_wt.svg") 
        fig.savefig("../fig/fig_cluster_recruitment_wt.png", dpi=dpi) 
        plt.show()

    def plot_diffusivity_wt(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        fig, ax = plt.subplots(figsize=figsize)

        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        self.D_model_pre = d_pre
        self.D_model_post = d_post

        print("Experimental:", self.D_exp_pre, self.D_exp_post)
        print("Model:", self.D_model_pre, self.D_model_post)

        mutants = ['WT']  #, r'$\Delta$C2A', 'shRNA RIM2', r'$\Delta$C2B']

        # Data
        D_exp_pre   = [self.D_exp_pre,]  #   self.D_exp_DC2A_pre,   self.D_exp_shRIM_pre,   self.D_exp_DC2B_pre]
        D_exp_post  = [self.D_exp_post,]  #  self.D_exp_DC2A_post,  self.D_exp_shRIM_post,  self.D_exp_DC2B_post]
        D_model_pre  = [self.D_model_pre,]  #  self.D_model_DC2A_pre,  self.D_model_shRIM_pre,  self.D_model_DC2B_pre]
        D_model_post = [self.D_model_post,]  # self.D_model_DC2A_post, self.D_model_shRIM_post, self.D_model_DC2B_post]

        D_exp_pre_sem  = [self.D_exp_pre_sem, ]  #  self.D_exp_DC2A_pre_sem,  self.D_exp_shRIM_pre_sem,  self.D_exp_DC2B_pre_sem]
        D_exp_post_sem = [self.D_exp_post_sem, ]  # self.D_exp_DC2A_post_sem, self.D_exp_shRIM_post_sem, self.D_exp_DC2B_post_sem]

        n = len(mutants)

        # Layout: [Exp(NO), Exp(STIM)]   gap   [Model(NO), Model(STIM)]
        bar_width   = 0.18
        small_gap   = 0.10   # separation between Exp pair and Model pair
        group_gap   = 0.60   # separation between mutant groups
        group_width = 4*bar_width + small_gap

        centers = np.arange(n) * (group_width + group_gap)
        lefts = centers - group_width/2

        x_exp_no   = lefts + 0*bar_width
        x_exp_stim = lefts + 1*bar_width
        x_mod_no   = lefts + 2*bar_width + small_gap
        x_mod_stim = lefts + 3*bar_width + small_gap

        # Colors and styles
        c_no, c_stim = 'black', 'red'
        hatch_model = '///'

        # EXP: solid fills (with error bars)
        ax.bar(x_exp_no,   D_exp_pre,  width=bar_width, yerr=D_exp_pre_sem,  capsize=4,
            color=c_no,   edgecolor='black', label='Exp (NO STIM)')
        ax.bar(x_exp_stim, D_exp_post, width=bar_width, yerr=D_exp_post_sem, capsize=4,
            color=c_stim, edgecolor='black', label='Exp (STIM)')

        # MODEL: hatched (use white fill + colored edge so the hatch stands out)
        ax.bar(x_mod_no,   D_model_pre,  width=bar_width,
            facecolor='white', edgecolor=c_no,   hatch=hatch_model, label='Model (NO STIM)')
        ax.bar(x_mod_stim, D_model_post, width=bar_width,
            facecolor='white', edgecolor=c_stim, hatch=hatch_model, label='Model (STIM)')

        # Axes/labels
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_xticks(centers)
        ax.set_xticklabels([], fontsize=fontsize)
        ax.tick_params(axis='y', labelsize=fontsize * 0.8)
        ax.set_ylim(bottom=0)

        # Adjust layout to fit
        plt.tight_layout(rect=[0, 0, 1, 0.95])

        # Cleanup
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_diffusivity_wt.svg") 
        fig.savefig("../fig/fig_diffusivity_wt.png", dpi=dpi) 
        plt.show()

    def plot_population_wt(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate)
        P_monomer_pre, P_dimer_pre, P_cluster_pre = self.calc_populations(solutionPre)
        P_monomer_post, P_dimer_post, P_cluster_post = self.calc_populations(solutionPost)

        print("Population NO STIM: Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_pre*100, P_dimer_pre*100, P_cluster_pre*100))
        print("Population STIM:    Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_post*100, P_dimer_post*100, P_cluster_post*100))

        # plot two pie charts side by side
        fig, ax = plt.subplots(1, 2, figsize=figsize)

        labels = ['M', 'D', 'C']
        sizes_pre = [P_monomer_pre, P_dimer_pre, P_cluster_pre]
        sizes_post = [P_monomer_post, P_dimer_post, P_cluster_post]
        colors = ['#ff9999','#66b3ff','#99ff99']
        explode = (0.05, 0.05, 0.05)  # explode all slices slightly
        wedges1, texts1, autotexts1 = ax[0].pie(sizes_pre, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        wedges2, texts2, autotexts2 = ax[1].pie(sizes_post, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        # draw circle for donut shape
        centre_circle0 = plt.Circle((0,0), 0.70, fc='white')
        centre_circle1 = plt.Circle((0,0), 0.70, fc='white')
        ax[0].add_artist(centre_circle0)
        ax[1].add_artist(centre_circle1)
        ax[0].set_title('NO STIM', fontsize=fontsize)
        ax[1].set_title('STIM', fontsize=fontsize)
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax[0].axis('equal')  
        ax[1].axis('equal')
        fig.tight_layout()
        fig.savefig("../fig/fig_population_wt.svg") 
        fig.savefig("../fig/fig_population_wt.png", dpi=dpi)
        plt.show()

    def plot_total_recruitment_dc2a(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c3 = candidate[3]
        candidate[3] = 0  # Set kfmm to 0 for deltaC2A scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[3] = c3

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, pre / self.Atotal, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, post / self.AtotalDense, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A density on membrane\n(copies/$\mu$m$^2$)")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 600)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_total_recruitment_dc2a.svg") 
        fig.savefig("../fig/fig_total_recruitment_dc2a.png", dpi=dpi) 
        plt.show()

    def plot_cluster_recruitment_dc2a(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        
        c3 = candidate[3]
        candidate[3] = 0  # Set kfmm to 0 for deltaC2A scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[3] = c3

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, preCluster, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, postCluster, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A copies in cluster")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 50)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_cluster_recruitment_dc2a.svg") 
        fig.savefig("../fig/fig_cluster_recruitment_dc2a.png", dpi=dpi) 
        plt.show()

    def plot_diffusivity_dc2a(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        fig, ax = plt.subplots(figsize=figsize)

        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        self.D_model_pre = d_pre
        self.D_model_post = d_post

        c3 = candidate[3]
        candidate[3] = 0  # Set kfmm to 0 for deltaC2A scenario
        solutionPre, solutionPost, _, _, d_pre, d_post = self.simulate(candidate)

        self.D_model_DC2A_pre = d_pre
        self.D_model_DC2A_post = d_post

        candidate[3] = c3

        print("Experimental:", self.D_exp_DC2A_pre, self.D_exp_DC2A_post)
        print("Model:", self.D_model_DC2A_pre, self.D_model_DC2A_post)

        mutants = ['WT', r'$\Delta$C2A',] # 'shRNA RIM2', r'$\Delta$C2B']

        # Data
        D_exp_pre   = [self.D_exp_pre, self.D_exp_DC2A_pre,] #   self.D_exp_shRIM_pre,   self.D_exp_DC2B_pre]
        D_exp_post  = [self.D_exp_post, self.D_exp_DC2A_post,] #  self.D_exp_shRIM_post,  self.D_exp_DC2B_post]
        D_model_pre  = [self.D_model_pre, self.D_model_DC2A_pre,] #  self.D_model_shRIM_pre,  self.D_model_DC2B_pre]
        D_model_post = [self.D_model_post, self.D_model_DC2A_post,] # self.D_model_shRIM_post, self.D_model_DC2B_post]

        D_exp_pre_sem  = [self.D_exp_pre_sem, self.D_exp_DC2A_pre_sem,] #  self.D_exp_shRIM_pre_sem,  self.D_exp_DC2B_pre_sem]
        D_exp_post_sem = [self.D_exp_post_sem, self.D_exp_DC2A_post_sem,] # self.D_exp_shRIM_post_sem, self.D_exp_DC2B_post_sem]

        n = len(mutants)

        # Layout: [Exp(NO), Exp(STIM)]   gap   [Model(NO), Model(STIM)]
        bar_width   = 0.18
        small_gap   = 0.10   # separation between Exp pair and Model pair
        group_gap   = 0.60   # separation between mutant groups
        group_width = 4*bar_width + small_gap

        centers = np.arange(n) * (group_width + group_gap)
        lefts = centers - group_width/2

        x_exp_no   = lefts + 0*bar_width
        x_exp_stim = lefts + 1*bar_width
        x_mod_no   = lefts + 2*bar_width + small_gap
        x_mod_stim = lefts + 3*bar_width + small_gap

        # Colors and styles
        c_no, c_stim = 'black', 'red'
        hatch_model = '///'

        # EXP: solid fills (with error bars)
        ax.bar(x_exp_no,   D_exp_pre,  width=bar_width, yerr=D_exp_pre_sem,  capsize=4,
            color=c_no,   edgecolor='black', label='Exp (NO STIM)')
        ax.bar(x_exp_stim, D_exp_post, width=bar_width, yerr=D_exp_post_sem, capsize=4,
            color=c_stim, edgecolor='black', label='Exp (STIM)')

        # MODEL: hatched (use white fill + colored edge so the hatch stands out)
        ax.bar(x_mod_no,   D_model_pre,  width=bar_width,
            facecolor='white', edgecolor=c_no,   hatch=hatch_model, label='Model (NO STIM)')
        ax.bar(x_mod_stim, D_model_post, width=bar_width,
            facecolor='white', edgecolor=c_stim, hatch=hatch_model, label='Model (STIM)')

        # Axes/labels
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_xticks(centers)
        ax.set_xticklabels(mutants, fontsize=fontsize)
        ax.tick_params(axis='y', labelsize=fontsize * 0.8)
        ax.set_ylim(bottom=0)

        # Adjust layout to fit
        plt.tight_layout(rect=[0, 0, 1, 0.95])

        # Cleanup
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        # ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_diffusivity_dc2a.svg") 
        fig.savefig("../fig/fig_diffusivity_dc2a.png", dpi=dpi) 
        plt.show()

    def plot_population_dc2a(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c3 = candidate[3]
        candidate[3] = 0  # Set kfmm to 0 for deltaC2A scenario

        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate)
        P_monomer_pre, P_dimer_pre, P_cluster_pre = self.calc_populations(solutionPre)
        P_monomer_post, P_dimer_post, P_cluster_post = self.calc_populations(solutionPost)

        candidate[3] = c3

        print("Population NO STIM: Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_pre*100, P_dimer_pre*100, P_cluster_pre*100))
        print("Population STIM:    Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_post*100, P_dimer_post*100, P_cluster_post*100))

        # plot two pie charts side by side
        fig, ax = plt.subplots(1, 2, figsize=figsize)

        labels = ['M', 'D', 'C']
        sizes_pre = [P_monomer_pre, P_dimer_pre, P_cluster_pre]
        sizes_post = [P_monomer_post, P_dimer_post, P_cluster_post]
        colors = ['#ff9999','#66b3ff','#99ff99']
        explode = (0.05, 0.05, 0.05)  # explode all slices slightly
        wedges1, texts1, autotexts1 = ax[0].pie(sizes_pre, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        wedges2, texts2, autotexts2 = ax[1].pie(sizes_post, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        # draw circle for donut shape
        centre_circle0 = plt.Circle((0,0), 0.70, fc='white')
        centre_circle1 = plt.Circle((0,0), 0.70, fc='white')
        ax[0].add_artist(centre_circle0)
        ax[1].add_artist(centre_circle1)
        ax[0].set_title('NO STIM', fontsize=fontsize)
        ax[1].set_title('STIM', fontsize=fontsize)
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax[0].axis('equal')  
        ax[1].axis('equal')
        fig.tight_layout()
        fig.savefig("../fig/fig_population_dc2a.svg") 
        fig.savefig("../fig/fig_population_dc2a.png", dpi=dpi)
        plt.show()

    def plot_total_recruitment_shrim(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c3 = candidate[3]
        candidate[3] = c3 * 2  # Set kfmm to 2x for shRNA RIM2 scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[3] = c3

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, pre / self.Atotal, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, post / self.AtotalDense, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A density on membrane\n(copies/$\mu$m$^2$)")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 600)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_total_recruitment_shrim.svg") 
        fig.savefig("../fig/fig_total_recruitment_shrim.png", dpi=dpi) 
        plt.show()

    def plot_cluster_recruitment_shrim(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        
        c3 = candidate[3]
        candidate[3] = c3 * 2  # Set kfmm to 2x for shRNA RIM2 scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[3] = c3

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, preCluster, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, postCluster, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A copies in cluster")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 50)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_cluster_recruitment_shrim.svg") 
        fig.savefig("../fig/fig_cluster_recruitment_shrim.png", dpi=dpi) 
        plt.show()

    def plot_diffusivity_shrim(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        fig, ax = plt.subplots(figsize=figsize)

        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        self.D_model_pre = d_pre
        self.D_model_post = d_post

        c3 = candidate[3]
        candidate[3] = c3 * 2  # Set kfmm to 2x for shRNA RIM2 scenario
        solutionPre, solutionPost, _, _, d_pre, d_post = self.simulate(candidate)

        self.D_model_shRIM_pre = d_pre
        self.D_model_shRIM_post = d_post

        candidate[3] = c3

        print("Experimental:", self.D_exp_shRIM_pre, self.D_exp_shRIM_post)
        print("Model:", self.D_model_shRIM_pre, self.D_model_shRIM_post)

        mutants = ['WT', 'shRNA RIM2',] # r'$\Delta$C2A', r'$\Delta$C2B']

        # Data
        D_exp_pre   = [self.D_exp_pre, self.D_exp_shRIM_pre,] #   self.D_exp_shRIM_pre,   self.D_exp_DC2B_pre]
        D_exp_post  = [self.D_exp_post, self.D_exp_shRIM_post,] #  self.D_exp_shRIM_post,  self.D_exp_DC2B_post]
        D_model_pre  = [self.D_model_pre, self.D_model_shRIM_pre,] #  self.D_model_shRIM_pre,  self.D_model_DC2B_pre]
        D_model_post = [self.D_model_post, self.D_model_shRIM_post,] # self.D_model_shRIM_post, self.D_model_DC2B_post]

        D_exp_pre_sem  = [self.D_exp_pre_sem, self.D_exp_shRIM_pre_sem,] #  self.D_exp_shRIM_pre_sem,  self.D_exp_DC2B_pre_sem]
        D_exp_post_sem = [self.D_exp_post_sem, self.D_exp_shRIM_post_sem,] # self.D_exp_shRIM_post_sem, self.D_exp_DC2B_post_sem]

        n = len(mutants)

        # Layout: [Exp(NO), Exp(STIM)]   gap   [Model(NO), Model(STIM)]
        bar_width   = 0.18
        small_gap   = 0.10   # separation between Exp pair and Model pair
        group_gap   = 0.60   # separation between mutant groups
        group_width = 4*bar_width + small_gap

        centers = np.arange(n) * (group_width + group_gap)
        lefts = centers - group_width/2

        x_exp_no   = lefts + 0*bar_width
        x_exp_stim = lefts + 1*bar_width
        x_mod_no   = lefts + 2*bar_width + small_gap
        x_mod_stim = lefts + 3*bar_width + small_gap

        # Colors and styles
        c_no, c_stim = 'black', 'red'
        hatch_model = '///'

        # EXP: solid fills (with error bars)
        ax.bar(x_exp_no,   D_exp_pre,  width=bar_width, yerr=D_exp_pre_sem,  capsize=4,
            color=c_no,   edgecolor='black', label='Exp (NO STIM)')
        ax.bar(x_exp_stim, D_exp_post, width=bar_width, yerr=D_exp_post_sem, capsize=4,
            color=c_stim, edgecolor='black', label='Exp (STIM)')

        # MODEL: hatched (use white fill + colored edge so the hatch stands out)
        ax.bar(x_mod_no,   D_model_pre,  width=bar_width,
            facecolor='white', edgecolor=c_no,   hatch=hatch_model, label='Model (NO STIM)')
        ax.bar(x_mod_stim, D_model_post, width=bar_width,
            facecolor='white', edgecolor=c_stim, hatch=hatch_model, label='Model (STIM)')

        # Axes/labels
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_xticks(centers)
        ax.set_xticklabels(mutants, fontsize=fontsize)
        ax.tick_params(axis='y', labelsize=fontsize * 0.8)
        ax.set_ylim(bottom=0)

        # Adjust layout to fit
        plt.tight_layout(rect=[0, 0, 1, 0.95])

        # Cleanup
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        # ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_diffusivity_shrim.svg") 
        fig.savefig("../fig/fig_diffusivity_shrim.png", dpi=dpi) 
        plt.show()

    def plot_population_shrim(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c3 = candidate[3]
        candidate[3] = c3 * 2  # Set kfmm to 2x for shRNA RIM2 scenario

        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate)
        P_monomer_pre, P_dimer_pre, P_cluster_pre = self.calc_populations(solutionPre)
        P_monomer_post, P_dimer_post, P_cluster_post = self.calc_populations(solutionPost)

        candidate[3] = c3

        print("Population NO STIM: Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_pre*100, P_dimer_pre*100, P_cluster_pre*100))
        print("Population STIM:    Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_post*100, P_dimer_post*100, P_cluster_post*100))

        # plot two pie charts side by side
        fig, ax = plt.subplots(1, 2, figsize=figsize)

        labels = ['M', 'D', 'C']
        sizes_pre = [P_monomer_pre, P_dimer_pre, P_cluster_pre]
        sizes_post = [P_monomer_post, P_dimer_post, P_cluster_post]
        colors = ['#ff9999','#66b3ff','#99ff99']
        explode = (0.05, 0.05, 0.05)  # explode all slices slightly
        wedges1, texts1, autotexts1 = ax[0].pie(sizes_pre, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        wedges2, texts2, autotexts2 = ax[1].pie(sizes_post, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        # draw circle for donut shape
        centre_circle0 = plt.Circle((0,0), 0.70, fc='white')
        centre_circle1 = plt.Circle((0,0), 0.70, fc='white')
        ax[0].add_artist(centre_circle0)
        ax[1].add_artist(centre_circle1)
        ax[0].set_title('NO STIM', fontsize=fontsize)
        ax[1].set_title('STIM', fontsize=fontsize)
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax[0].axis('equal')  
        ax[1].axis('equal')
        fig.tight_layout()
        fig.savefig("../fig/fig_population_shrim.svg") 
        fig.savefig("../fig/fig_population_shrim.png", dpi=dpi)
        plt.show()

    def plot_total_recruitment_dc2b(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c0 = candidate[0]
        candidate[0] = c0 * 0.5  # Set kfsr to 0.5x for DeltaC2B scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[0] = c0

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, pre / self.Atotal, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, post / self.AtotalDense, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A density on membrane\n(copies/$\mu$m$^2$)")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 600)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_total_recruitment_dc2b.svg") 
        fig.savefig("../fig/fig_total_recruitment_dc2b.png", dpi=dpi) 
        plt.show()

    def plot_cluster_recruitment_dc2b(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        
        c0 = candidate[0]
        candidate[0] = c0 * 0.5  # Set kfsr to 0.5x for DeltaC2B scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[0] = c0

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, preCluster, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, postCluster, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A copies in cluster")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 50)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_cluster_recruitment_dc2b.svg") 
        fig.savefig("../fig/fig_cluster_recruitment_dc2b.png", dpi=dpi) 
        plt.show()

    def plot_diffusivity_dc2b(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        fig, ax = plt.subplots(figsize=figsize)

        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        self.D_model_pre = d_pre
        self.D_model_post = d_post

        c0 = candidate[0]
        candidate[0] = c0 * 0.5  # Set kfsr to 0.5x for DeltaC2B scenario
        solutionPre, solutionPost, _, _, d_pre, d_post = self.simulate(candidate)

        self.D_model_DC2B_pre = d_pre
        self.D_model_DC2B_post = d_post

        candidate[0] = c0

        print("Experimental:", self.D_exp_DC2B_pre, self.D_exp_DC2B_post)
        print("Model:", self.D_model_DC2B_pre, self.D_model_DC2B_post)

        mutants = ['WT', r'$\Delta$C2B',] # r'$\Delta$C2A', r'$\Delta$C2B']

        # Data
        D_exp_pre   = [self.D_exp_pre, self.D_exp_DC2B_pre,] #   self.D_exp_shRIM_pre,   self.D_exp_DC2B_pre]
        D_exp_post  = [self.D_exp_post, self.D_exp_DC2B_post,] #  self.D_exp_shRIM_post,  self.D_exp_DC2B_post]
        D_model_pre  = [self.D_model_pre, self.D_model_DC2B_pre,] #  self.D_model_shRIM_pre,  self.D_model_DC2B_pre]
        D_model_post = [self.D_model_post, self.D_model_DC2B_post,] # self.D_model_shRIM_post, self.D_model_DC2B_post]

        D_exp_pre_sem  = [self.D_exp_pre_sem, self.D_exp_DC2B_pre_sem,] #  self.D_exp_shRIM_pre_sem,  self.D_exp_DC2B_pre_sem]
        D_exp_post_sem = [self.D_exp_post_sem, self.D_exp_DC2B_post_sem,] # self.D_exp_shRIM_post_sem, self.D_exp_DC2B_post_sem]

        n = len(mutants)

        # Layout: [Exp(NO), Exp(STIM)]   gap   [Model(NO), Model(STIM)]
        bar_width   = 0.18
        small_gap   = 0.10   # separation between Exp pair and Model pair
        group_gap   = 0.60   # separation between mutant groups
        group_width = 4*bar_width + small_gap

        centers = np.arange(n) * (group_width + group_gap)
        lefts = centers - group_width/2

        x_exp_no   = lefts + 0*bar_width
        x_exp_stim = lefts + 1*bar_width
        x_mod_no   = lefts + 2*bar_width + small_gap
        x_mod_stim = lefts + 3*bar_width + small_gap

        # Colors and styles
        c_no, c_stim = 'black', 'red'
        hatch_model = '///'

        # EXP: solid fills (with error bars)
        ax.bar(x_exp_no,   D_exp_pre,  width=bar_width, yerr=D_exp_pre_sem,  capsize=4,
            color=c_no,   edgecolor='black', label='Exp (NO STIM)')
        ax.bar(x_exp_stim, D_exp_post, width=bar_width, yerr=D_exp_post_sem, capsize=4,
            color=c_stim, edgecolor='black', label='Exp (STIM)')

        # MODEL: hatched (use white fill + colored edge so the hatch stands out)
        ax.bar(x_mod_no,   D_model_pre,  width=bar_width,
            facecolor='white', edgecolor=c_no,   hatch=hatch_model, label='Model (NO STIM)')
        ax.bar(x_mod_stim, D_model_post, width=bar_width,
            facecolor='white', edgecolor=c_stim, hatch=hatch_model, label='Model (STIM)')

        # Axes/labels
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_xticks(centers)
        ax.set_xticklabels(mutants, fontsize=fontsize)
        ax.tick_params(axis='y', labelsize=fontsize * 0.8)
        ax.set_ylim(bottom=0)

        # Adjust layout to fit
        plt.tight_layout(rect=[0, 0, 1, 0.95])

        # Cleanup
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        # ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_diffusivity_dc2b.svg") 
        fig.savefig("../fig/fig_diffusivity_dc2b.png", dpi=dpi) 
        plt.show()

    def plot_population_dc2b(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c0 = candidate[0]
        candidate[0] = c0 * 0.5  # Set kfsr to 0.5x for DeltaC2B scenario

        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate)
        P_monomer_pre, P_dimer_pre, P_cluster_pre = self.calc_populations(solutionPre)
        P_monomer_post, P_dimer_post, P_cluster_post = self.calc_populations(solutionPost)

        candidate[0] = c0

        print("Population NO STIM: Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_pre*100, P_dimer_pre*100, P_cluster_pre*100))
        print("Population STIM:    Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_post*100, P_dimer_post*100, P_cluster_post*100))

        # plot two pie charts side by side
        fig, ax = plt.subplots(1, 2, figsize=figsize)

        labels = ['M', 'D', 'C']
        sizes_pre = [P_monomer_pre, P_dimer_pre, P_cluster_pre]
        sizes_post = [P_monomer_post, P_dimer_post, P_cluster_post]
        colors = ['#ff9999','#66b3ff','#99ff99']
        explode = (0.05, 0.05, 0.05)  # explode all slices slightly
        wedges1, texts1, autotexts1 = ax[0].pie(sizes_pre, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        wedges2, texts2, autotexts2 = ax[1].pie(sizes_post, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        # draw circle for donut shape
        centre_circle0 = plt.Circle((0,0), 0.70, fc='white')
        centre_circle1 = plt.Circle((0,0), 0.70, fc='white')
        ax[0].add_artist(centre_circle0)
        ax[1].add_artist(centre_circle1)
        ax[0].set_title('NO STIM', fontsize=fontsize)
        ax[1].set_title('STIM', fontsize=fontsize)
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax[0].axis('equal')  
        ax[1].axis('equal')
        fig.tight_layout()
        fig.savefig("../fig/fig_population_dc2b.svg") 
        fig.savefig("../fig/fig_population_dc2b.png", dpi=dpi)
        plt.show()

    def plot_total_recruitment_endogenous(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c7 = candidate[7]
        candidate[7] = c7 * 0.1  # Set munc13 concentration to 0.1x for endogenous munc13 scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[7] = c7

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, pre / self.Atotal, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, post / self.AtotalDense, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A density on membrane\n(copies/$\mu$m$^2$)")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 600)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_total_recruitment_endogenous.svg") 
        fig.savefig("../fig/fig_total_recruitment_endogenous.png", dpi=dpi) 
        plt.show()

    def plot_cluster_recruitment_endogenous(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        
        c7 = candidate[7]
        candidate[7] = c7 * 0.1  # Set munc13 concentration to 0.1x for endogenous munc13 scenario
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        candidate[7] = c7

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM
        fig, ax = plt.subplots(figsize=figsize)
        ax.plot(self.timePoints, preCluster, linestyle="-", label="NO STIM", color=c_pre, alpha=0.95, zorder=3)
        ax.plot(self.timePoints, postCluster, linestyle="-", label="STIM", color=c_post, alpha=0.95, zorder=3)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Unc13A copies in cluster")
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 50)
        ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_cluster_recruitment_endogenous.svg") 
        fig.savefig("../fig/fig_cluster_recruitment_endogenous.png", dpi=dpi) 
        plt.show()

    def plot_diffusivity_endogenous(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)
        fig, ax = plt.subplots(figsize=figsize)

        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        self.D_model_pre = d_pre
        self.D_model_post = d_post

        c7 = candidate[7]
        candidate[7] = c7 * 0.1  # Set munc13 concentration to 0.1x for endogenous munc13 scenario
        solutionPre, solutionPost, _, _, d_pre, d_post = self.simulate(candidate)

        self.D_model_endogenous_pre = d_pre
        self.D_model_endogenous_post = d_post

        candidate[7] = c7

        # print("Experimental:", self.D_exp_endogenous_pre, self.D_exp_endogenous_post)
        print("Model:", self.D_model_endogenous_pre, self.D_model_endogenous_post)

        mutants = ['WT', 'Endogenous',] # r'$\Delta$C2A', r'$\Delta$C2B']

        # Data
        D_exp_pre   = [self.D_exp_pre, 0,] #   self.D_exp_shRIM_pre,   self.D_exp_DC2B_pre]
        D_exp_post  = [self.D_exp_post, 0,] #  self.D_exp_shRIM_post,  self.D_exp_DC2B_post]
        D_model_pre  = [self.D_model_pre, self.D_model_endogenous_pre,] #  self.D_model_shRIM_pre,  self.D_model_DC2B_pre]
        D_model_post = [self.D_model_post, self.D_model_endogenous_post,] # self.D_model_shRIM_post, self.D_model_DC2B_post]

        D_exp_pre_sem  = [self.D_exp_pre_sem, 0,] #  self.D_exp_shRIM_pre_sem,  self.D_exp_DC2B_pre_sem]
        D_exp_post_sem = [self.D_exp_post_sem, 0,] # self.D_exp_shRIM_post_sem, self.D_exp_DC2B_post_sem]

        n = len(mutants)

        # Layout: [Exp(NO), Exp(STIM)]   gap   [Model(NO), Model(STIM)]
        bar_width   = 0.18
        small_gap   = 0.10   # separation between Exp pair and Model pair
        group_gap   = 0.60   # separation between mutant groups
        group_width = 4*bar_width + small_gap

        centers = np.arange(n) * (group_width + group_gap)
        lefts = centers - group_width/2

        x_exp_no   = lefts + 0*bar_width
        x_exp_stim = lefts + 1*bar_width
        x_mod_no   = lefts + 2*bar_width + small_gap
        x_mod_stim = lefts + 3*bar_width + small_gap

        # Colors and styles
        c_no, c_stim = 'black', 'red'
        hatch_model = '///'

        # EXP: solid fills (with error bars)
        ax.bar(x_exp_no,   D_exp_pre,  width=bar_width, yerr=D_exp_pre_sem,  capsize=4,
            color=c_no,   edgecolor='black', label='Exp (NO STIM)')
        ax.bar(x_exp_stim, D_exp_post, width=bar_width, yerr=D_exp_post_sem, capsize=4,
            color=c_stim, edgecolor='black', label='Exp (STIM)')

        # MODEL: hatched (use white fill + colored edge so the hatch stands out)
        ax.bar(x_mod_no,   D_model_pre,  width=bar_width,
            facecolor='white', edgecolor=c_no,   hatch=hatch_model, label='Model (NO STIM)')
        ax.bar(x_mod_stim, D_model_post, width=bar_width,
            facecolor='white', edgecolor=c_stim, hatch=hatch_model, label='Model (STIM)')

        # Axes/labels
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_xticks(centers)
        ax.set_xticklabels(mutants, fontsize=fontsize)
        ax.tick_params(axis='y', labelsize=fontsize * 0.8)
        ax.set_ylim(bottom=0)

        # Adjust layout to fit
        plt.tight_layout(rect=[0, 0, 1, 0.95])

        # Cleanup
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        # ax.legend()
        fig.tight_layout()

        fig.savefig("../fig/fig_diffusivity_endogenous.svg") 
        fig.savefig("../fig/fig_diffusivity_endogenous.png", dpi=dpi) 
        plt.show()

    def plot_population_endogenous(self, select=3, figsize=(4, 3), fontsize=12, dpi=300):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        candidate = self.filteredSolutions[select]
        print("candinate: ", candidate)

        c7 = candidate[7]
        candidate[7] = c7 * 0.1  # Set munc13 concentration to 0.1x for endogenous munc13 scenario

        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate)
        P_monomer_pre, P_dimer_pre, P_cluster_pre = self.calc_populations(solutionPre)
        P_monomer_post, P_dimer_post, P_cluster_post = self.calc_populations(solutionPost)

        candidate[7] = c7

        print("Population NO STIM: Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_pre*100, P_dimer_pre*100, P_cluster_pre*100))
        print("Population STIM:    Monomer: %.2f%%, Dimer: %.2f%%, Cluster: %.2f%%" % (P_monomer_post*100, P_dimer_post*100, P_cluster_post*100))

        # plot two pie charts side by side
        fig, ax = plt.subplots(1, 2, figsize=figsize)

        labels = ['M', 'D', 'C']
        sizes_pre = [P_monomer_pre, P_dimer_pre, P_cluster_pre]
        sizes_post = [P_monomer_post, P_dimer_post, P_cluster_post]
        colors = ['#ff9999','#66b3ff','#99ff99']
        explode = (0.05, 0.05, 0.05)  # explode all slices slightly
        wedges1, texts1, autotexts1 = ax[0].pie(sizes_pre, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        wedges2, texts2, autotexts2 = ax[1].pie(sizes_post, explode=explode, labels=labels, colors=colors,
                autopct='%1.1f%%', startangle=140, pctdistance=0.85, textprops={'fontsize': fontsize * 0.8})
        # draw circle for donut shape
        centre_circle0 = plt.Circle((0,0), 0.70, fc='white')
        centre_circle1 = plt.Circle((0,0), 0.70, fc='white')
        ax[0].add_artist(centre_circle0)
        ax[1].add_artist(centre_circle1)
        ax[0].set_title('NO STIM', fontsize=fontsize)
        ax[1].set_title('STIM', fontsize=fontsize)
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax[0].axis('equal')  
        ax[1].axis('equal')
        fig.tight_layout()
        fig.savefig("../fig/fig_population_endogenous.svg") 
        fig.savefig("../fig/fig_population_endogenous.png", dpi=dpi)
        plt.show()

    # plot the total munc13 in cluster, compared with experimental kinetic, nerdss simulaition data
    def plot_cluster_kinetic(self, best=300, select=297, totalTime=10.0, dt=0.1, figsize=(9,6), fontsize=12, dpi=600):
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        idx = select
        candidate = self.filteredSolutions[idx]
        print("candinate: ", candidate)

        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        data = {
            "timePoints": self.timePoints,
            "preCluster": preCluster,
            "postCluster": postCluster,
            "pre": pre,
            "post": post
        }
        df = pd.DataFrame(data)
        df.to_csv(f"../../NERDSS/data/munc13_copies_ode.csv", index=False)
        
        data = {
            "timePoints": self.timePointsPre,
            "preEq": preEq,
            "postEq": postEq
        }
        df = pd.DataFrame(data)
        df.to_csv(f"../../NERDSS/data/munc13_copies_eq_ode.csv", index=False)

        df_pre = pd.read_csv("../../NERDSS/data/stochastic_pre.csv")
        df_post = pd.read_csv("../../NERDSS/data/stochastic_post.csv")

        # ----- Publication-oriented defaults -----
        plt.rcParams.update({
            "figure.dpi": 300, "savefig.dpi": 300,
            "font.size": fontsize, "axes.labelsize": fontsize, "axes.titlesize": fontsize,
            "legend.fontsize": fontsize, "xtick.labelsize": fontsize, "ytick.labelsize": fontsize,
            "axes.linewidth": 0.8, "lines.linewidth": 1.4,
            "pdf.fonttype": 42, "ps.fonttype": 42,  # editable text in vector exports
        })

        fig, ax = plt.subplots(figsize=figsize)

        c_pre  = "black"   # NO STIM
        c_post = "red"     # STIM

        # --- PRE (NO STIM): scatter means + SEM band + ODE line + experiment---
        pre_t   = df_pre["timePoints"].to_numpy()
        pre_m   = df_pre["munc13_cluster_mean"].to_numpy()
        pre_sem = df_pre["munc13_cluster_sem"].to_numpy()

        # Errorbar points
        err1 = ax.errorbar(
            pre_t, pre_m, yerr=pre_sem,
            fmt="o", ms=3, mfc="white", mew=0.9,
            capsize=2, elinewidth=0.9,
            label="NO STIM: NERDSS",
            color=c_pre, ecolor=c_pre, linestyle="none", zorder=2
        )

        # ODE line
        line_pre, = ax.plot(self.timePoints, preCluster, linestyle="-", label="NO STIM: ODE", color=c_pre, alpha=0.95, zorder=3)

        # plot experiment
        # NO STIM
        solutionPre, solutionPost, _, _, Dpre, Dpost = self.simulate(candidate)
        _, _, preCluster, postCluster, pre, post, preEq, postEq,_,_,_,_,_,_ = self.calculate_results(candidate)
        mc, md = self.get_cluster_time_series(solutionPre, False)
        fold_increase = self.get_simulated_fold_change(mc, md)
        delta = self.compute_background_from_target_increase(fold_increase)

        relInt = (self.expdata.expInt - delta) / (self.expdata.expInt[0] - delta)
        sem = self.expdata.expSEM / (self.expdata.expInt[0] - delta)
        time = self.expdata.time
        ax.errorbar(time, relInt * preCluster[0], yerr=sem * preCluster[0], linestyle="--", color=c_pre, alpha=0.95, label='NO STIM: Exp')

        # --- POST (STIM): scatter means + SEM band + ODE line + experiemnt---
        post_t   = df_post["timePoints"].to_numpy()
        post_m   = df_post["munc13_cluster_mean"].to_numpy()
        post_sem = df_post["munc13_cluster_sem"].to_numpy()

        err2 = ax.errorbar(
            post_t, post_m, yerr=post_sem,
            fmt="s", ms=3, mfc="white", mew=0.9,
            capsize=2, elinewidth=0.9,
            label="STIM: NERDSS",
            color=c_post, ecolor=c_post, linestyle="none", zorder=2
        )

        line_post, = ax.plot(self.timePoints, postCluster, linestyle="-", label="STIM: ODE", color=c_post, alpha=0.95, zorder=3)

        # STIM
        mc, md = self.get_cluster_time_series(solutionPost, True)
        fold_increase = self.get_simulated_fold_change(mc, md)
        delta = self.compute_background_from_target_increase(fold_increase)

        relInt = (self.expdata.expInt - delta) / (self.expdata.expInt[0] - delta)
        sem = self.expdata.expSEM / (self.expdata.expInt[0] - delta)
        time = self.expdata.time
        ax.errorbar(time, relInt * postCluster[0], yerr=sem * postCluster[0], linestyle="--", color=c_post, alpha=0.95, label='STIM: Exp')
    
        # ----- Axes cosmetics -----
        ax.set_xlabel("Time (s)")                       # adjust units/label to yours
        ax.set_ylabel("Unc13A Copies in Cluster Region")   # adjust units/label to yours

        ax.legend(fontsize=12)

        fig.tight_layout()

        # Save as vector + raster
        fig.savefig("../fig/munc13_timecourse.svg")  # vector for journals
        fig.savefig("../fig/munc13_timecourse.png", dpi=dpi)  # raster fallback
        plt.show()

    # plot the diffusion constants of dilute phase; plot the percentage of cluster copies
    def plot_diffusion_dilute_percentage_cluster(self, select=298, figsize=(2.8, 7), fontsize=18, dpi=600):
        """
        Average diffusion of Munc13 copies in the dilute phase and percentage of Munc13 copies in the cluster.
        """
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        if not hasattr(self, "filteredSolutions") or not self.filteredSolutions:
            print("Filtered solutions not found. Run `filter_and_store_solutions()` first.")
            return

        idx = select
        candidate = self.filteredSolutions[idx]
        print(candidate)
        
        D1 = candidate[9]  # Monomer diffusion constant on membrane
        D2 = candidate[9] / candidate[10] # Dimer diffusion constant on membrane
        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate)

        D_dilute_pre = self.calc_diffusion_dilute(D1, D2, solutionPre)
        D_dilute_post = self.calc_diffusion_dilute(D1, D2, solutionPost)
        perc_cluster_pre = self.calc_percentages_cluster(solutionPre)
        perc_cluster_post = self.calc_percentages_cluster(solutionPost)
        _, perc_cluster_pre_2D = self.calc_3D_2D_percentages_cluster(solutionPre)
        _, perc_cluster_post_2D = self.calc_3D_2D_percentages_cluster(solutionPost)

        print(f"Average Diffusion in Dilute Phase: No Stim={D_dilute_pre:.4f}, Stim={D_dilute_post:.4f}")
        print(f"Percentage of Munc13 in Cluster: No Stim={perc_cluster_pre:.4f}, Stim={perc_cluster_post:.4f}")
        print(f"Percentage of Munc13 in Cluster From 2D: No Stim={perc_cluster_pre:.4f}, Stim={perc_cluster_post:.4f}")

        categories = ["NO STIM", "STIM"]
        x = np.arange(len(categories))
        width = 0.35

        # Plot: Diffusion constants in dilute phase
        fig, axe = plt.subplots(1, 1, figsize=figsize, dpi=dpi)
    
        axe.bar(x, [D_dilute_pre, D_dilute_post], width, capsize=5, label="Model", color=['black', 'red'], alpha=1.0)
    
        axe.set_xticks(x)
        axe.set_xticklabels(categories, fontsize=fontsize)
        axe.set_ylabel(r"$\mathrm{Average\ Diffusion\ out\ of\ Cluster}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        # axe.set_title("Average Diffusion in Dilute Phase", fontsize=fontsize)
        fig.tight_layout()
        fig.savefig("../data/dilute_diffusion.png", dpi=dpi, bbox_inches="tight")
        plt.show()

        # Plot: Percentage of Munc13 copies in the cluster
        fig, axe = plt.subplots(1, 1, figsize=figsize, dpi=dpi)
    
        axe.bar(x, [perc_cluster_pre*100, perc_cluster_post*100], width, capsize=5, label="Model", color=['black', 'red'], alpha=1.0)
    
        axe.set_xticks(x)
        axe.set_xticklabels(categories, fontsize=fontsize)
        axe.set_ylabel(r"$\mathrm{Unc13A\ in\ Cluster}\ (\%)$", fontsize=fontsize)
        # axe.set_title("Percentage of Munc13 in Cluster", fontsize=fontsize)
        fig.tight_layout()
        fig.savefig("../data/cluster_perc.png", dpi=dpi, bbox_inches="tight")
        plt.show()

        # Plot: Percentage of Munc13 from 2D in the cluster
        fig, axe = plt.subplots(1, 1, figsize=figsize, dpi=dpi)
    
        axe.bar(x, [perc_cluster_pre_2D*100, perc_cluster_post_2D*100], width, capsize=5, label="Model", color=['black', 'red'], alpha=1.0)
    
        axe.set_xticks(x)
        axe.set_xticklabels(categories, fontsize=fontsize)
        axe.set_ylabel(r"$\mathrm{2D\ Lateral\ Recruitment\ to\ Cluster}\ (\%)$", fontsize=fontsize)
        # axe.set_title("Percentage of Munc13 in Cluster from 2D", fontsize=fontsize)
        fig.tight_layout()
        fig.savefig("../data/cluster_from2D.png", dpi=dpi, bbox_inches="tight")
        plt.show()

    # plot the distribution of optimized parameters
    def plot_parms(self, best=100, select=100, totalTime=10.0, dt=0.1,
               parameter_ranges=None, percent=None, figsize=(16,12),
               fontsize=18, dpi=600, bins_per_decade=10):
        """
        Create figure: hist of parameter values with even-width bars in log space.
        """
        from matplotlib.ticker import LogLocator, LogFormatterMathtext, NullFormatter

        # ------------------------------ style -----------------------------------
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        if parameter_ranges is None:
            parameter_ranges = {
                "kfsr":          {"min": 0.001, "max": 10},
                "krsr_nostim":   {"min": 0.1,   "max": 1000},
                "krsr_stim":     {"min": 0.1,   "max": 1000},
                "kfmm":          {"min": 0.001, "max": 10},
                "krmm":          {"min": 0.01,  "max": 100},
                "kfc_nostim":    {"min": 0.001, "max": 10},
                "kfc_stim":      {"min": 0.001, "max": 10},
                "S0":            {"min": 0.01,  "max": 10},
                "R0":            {"min": 100,   "max": 500},
                "D1":            {"min": 0.05,  "max": 5},
                "D1_over_D2":    {"min": 1.5,   "max": 5},
                "X":             {"min": 10,    "max": 10},     # constant
            }

        # helper: log-spaced bin edges (even in log space)
        def _log_bins(lo, hi, bpd=bins_per_decade):
            lo = max(lo, np.finfo(float).tiny)
            exp_lo = np.floor(np.log10(lo))
            exp_hi = np.ceil(np.log10(hi))
            n = max(1, int((exp_hi - exp_lo) * bpd))
            return np.logspace(exp_lo, exp_hi, n + 1)

        # --------------------- model times for completeness ---------------------
        self.t_max = totalTime
        n_time_points = int(totalTime / dt)
        self.timePoints = [i * dt for i in range(n_time_points + 1)]

        # --------------------- load and pick solutions --------------------------
        df = pd.read_csv("../data/optimizedParms.txt", sep=",", engine="python")
        df.columns = df.columns.str.strip()
        df = df.sort_values(by="Rank")

        solutions = []
        for _, row in df.iterrows():
            rank = int(row["Rank"])
            fitness = float(row["Fitness"])
            param_cols_all = [c for c in df.columns if c not in ["Rank", "Fitness"]]
            param_vector = [float(row[c]) for c in param_cols_all]
            solutions.append((rank, fitness, param_vector))

        if percent is not None:
            n_solutions = len(solutions)
            n_to_consider = max(1, int(n_solutions * percent / 100))
            best = n_to_consider
            select = n_to_consider

        print(f"Total solutions loaded: {len(solutions)}")
        if percent:
            print(f"Filtering solutions within {percent}% of best fitness.")
        print(f"Considering top {best} solutions by rank.")

        filtered_solutions = [sol for sol in solutions if sol[0] < best]
        if len(filtered_solutions) < select:
            select = len(filtered_solutions)

        rng = np.random.default_rng()
        random_indices = rng.choice(len(filtered_solutions), size=select, replace=False)
        print(f"Randomly selected {select} solutions for parameter histograms.")

        # --------------------------- prepare data -------------------------------
        param_cols = [c for c in df.columns if c not in ["Rank", "Fitness"]]
        n_params = len(param_cols)

        param_matrix = np.array([filtered_solutions[i][2] for i in random_indices],
                                dtype=float)  # shape: (select, n_params)

        parms_name_map = {
            'kfsr': r'$kf_{SR}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'krsr_nostim': r'$kr_{SR,\mathrm{NOSTIM}}\; (\mathrm{s}^{-1})$',
            'krsr_stim': r'$kr_{SR,\mathrm{STIM}}\; (\mathrm{s}^{-1})$',
            'kfmm': r'$kf_{MM}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'krmm': r'$kr_{MM}\; (\mathrm{s}^{-1})$',
            'kfc_nostim': r'$kf_{C,\mathrm{NOSTIM}}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'kfc_stim': r'$kf_{C,\mathrm{STIM}}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'S0': r'$S_{0}\; (\mu\mathrm{M})$',
            'R0': r'$R_{0}\; (\mathrm{copies}/\mu\mathrm{m}^{2})$',
            'D1': r'$D_{1}\; (\mu\mathrm{m}^{2}/\mathrm{s})$',
            'D1_over_D2': r'$D_{1} / D_{2}$',
            'X': r'$X$'
        }

        # ----------------------------- plotting --------------------------------
        fig1, axes1 = plt.subplots(3, 4, figsize=figsize, dpi=dpi)
        axes1 = axes1.flatten()

        for idx, ax in enumerate(axes1):
            if idx >= n_params:
                ax.set_visible(False)
                continue

            col_name = param_cols[idx]
            vals = np.asarray(param_matrix[:, idx], dtype=float)

            # keep positives only (log scale)
            positive = vals[vals > 0]
            if positive.size == 0:
                ax.text(0.5, 0.5, "no positive values", ha="center", va="center",
                        transform=ax.transAxes)
                ax.set_title(parms_name_map.get(col_name, col_name))
                ax.set_xlabel("Value")
                ax.set_ylabel("Frequency")
                continue

            # choose plotting range
            if col_name in parameter_ranges:
                p = parameter_ranges[col_name]
                lo = p["min"] * 0.1
                hi = p["max"] * 10
            else:
                raise ValueError(f"Parameter '{col_name}' not found in provided ranges.")

            # log-spaced bins -> even widths in log space
            bins = _log_bins(lo, hi, bpd=bins_per_decade)
            ax.hist(positive, bins=bins, edgecolor="black", alpha=0.7)

            # log axis and tidy ticks
            ax.set_xscale("log")
            ax.set_xlim(lo, hi)
            ax.xaxis.set_major_locator(LogLocator(base=10.0, numticks=6))
            ax.xaxis.set_major_formatter(LogFormatterMathtext())
            ax.xaxis.set_minor_locator(LogLocator(base=10.0,
                                                subs=np.arange(2, 10) * 0.1,
                                                numticks=12))
            ax.xaxis.set_minor_formatter(NullFormatter())
            ax.tick_params(axis='x', which='major', labelsize=fontsize-2)
            ax.tick_params(axis='x', which='minor', length=3)

            # helpful light grid
            ax.grid(True, which='both', axis='x', alpha=0.15)

            # show allowed range bounds if provided
            if col_name in parameter_ranges:
                ax.axvline(parameter_ranges[col_name]["min"], color='red', ls='--', lw=2)
                ax.axvline(parameter_ranges[col_name]["max"], color='red', ls='--', lw=2)

            ax.set_title(parms_name_map.get(col_name, col_name))
            ax.set_xlabel("Value")
            ax.set_ylabel("Frequency")

        fig1.tight_layout(rect=[0, 0, 1, 0.97])
        fig1.savefig("../fig/params-distribution.png", dpi=dpi, bbox_inches="tight")

    def plot_parameter_ranges_summary(
        self,
        best=100,
        select=100,
        totalTime=10.0,
        dt=0.1,
        parameter_ranges=None,
        percent=10,                    # use top `percent`% of solutions by Rank
        figsize=(11, 7),
        fontsize=16,
        dpi=600,
        bar_width=0.7,
        save_path="../fig/params-summary.png",
    ):
        """
        Summary plot of parameter ranges:
        - Grey bar: allowed range (from `parameter_ranges` or data span fallback).
        - Light blue bar: range across the top `percent`% solutions by Rank.
        - Dark blue line: best (lowest-Rank) value.

        `percent=10` on a file with 1000 rows uses the best 100 rows by Rank.
        """
        from matplotlib.ticker import LogLocator, LogFormatterMathtext, NullFormatter
        import matplotlib.patches as patches
        from matplotlib.lines import Line2D

        # ------------------------------ style -----------------------------------
        sns.set_style("ticks")
        sns.set_context("paper", rc={
            "font.size": fontsize,
            "axes.titlesize": fontsize,
            "axes.labelsize": fontsize,
            "xtick.labelsize": fontsize,
            "ytick.labelsize": fontsize,
            "legend.fontsize": fontsize,
            "font.family": "serif"
        })

        if parameter_ranges is None:
            parameter_ranges = {
                "kfsr":          {"min": 0.001, "max": 10},
                "krsr_nostim":   {"min": 0.1,   "max": 1000},
                "krsr_stim":     {"min": 0.1,   "max": 1000},
                "kfmm":          {"min": 0.001, "max": 10},
                "krmm":          {"min": 0.01,  "max": 100},
                "kfc_nostim":    {"min": 0.001, "max": 10},
                "kfc_stim":      {"min": 0.001, "max": 10},
                "S0":            {"min": 0.01,  "max": 10},
                "R0":            {"min": 100,   "max": 500},
                "D1":            {"min": 0.05,  "max": 5},
                "D1_over_D2":    {"min": 1.5,   "max": 5},
                "X":             {"min": 10,    "max": 10},     # constant
            }

        # --------------------- model times for completeness ---------------------
        self.t_max = totalTime
        n_time_points = int(totalTime / dt)
        self.timePoints = [i * dt for i in range(n_time_points + 1)]

        # --------------------- load solutions -----------------------------------
        df = pd.read_csv("../data/optimizedParms.txt", sep=",", engine="python")
        df.columns = df.columns.str.strip()

        # Parameter columns = everything except bookkeeping
        param_cols = [c for c in df.columns if c not in ("Rank", "Fitness")]
        if not param_cols:
            raise ValueError("No parameter columns found in optimizedParms.txt")

        # Best-by-rank subset size
        n_total = len(df)
        n_best = max(1, int(np.floor(n_total * (percent / 100.0))))
        # Best subset by Rank (smaller Rank = better)
        best_df = df.nsmallest(n_best, "Rank")
        best_row = df.nsmallest(1, "Rank").iloc[0]

        print(f"Total solutions loaded: {n_total}")
        print(f"Using top {percent}% by Rank -> {n_best} solutions.")

        # -------------------- labels --------------------------------------------
        parms_name_map = {
            'kfsr': r'$kf_{SR}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'krsr_nostim': r'$kr_{SR,\mathrm{NOSTIM}}\; (\mathrm{s}^{-1})$',
            'krsr_stim': r'$kr_{SR,\mathrm{STIM}}\; (\mathrm{s}^{-1})$',
            'kfmm': r'$kf_{MM}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'krmm': r'$kr_{MM}\; (\mathrm{s}^{-1})$',
            'kfc_nostim': r'$kf_{C,\mathrm{NOSTIM}}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'kfc_stim': r'$kf_{C,\mathrm{STIM}}\; (\mu\mathrm{M}^{-1}\,\mathrm{s}^{-1})$',
            'S0': r'$S_{0}\; (\mu\mathrm{M})$',
            'R0': r'$R_{0}\; (\mathrm{copies}/\mu\mathrm{m}^{2})$',
            'D1': r'$D_{1}\; (\mu\mathrm{m}^{2}/\mathrm{s})$',
            'D1_over_D2': r'$D_{1} / D_{2}$',
            'X': r'$X$'
        }

        tiny = np.finfo(float).tiny

        # -------------------- allowed ranges (grey) ------------------------------
        pr = {}
        for p in param_cols:
            if p in parameter_ranges:
                lo = max(parameter_ranges[p]["min"], tiny)
                hi = parameter_ranges[p]["max"]
            else:
                raise ValueError(f"Parameter '{p}' not found in provided ranges.")
            if hi <= lo or np.isclose(np.log10(hi) - np.log10(lo), 0.0):
                lo *= 0.9
                hi *= 1.1
            pr[p] = {"min": lo, "max": hi}

        # ------------- range across the best `percent`% (light blue) ------------
        subset_ranges = {}
        for p in param_cols:
            col = best_df[p].to_numpy(float)
            col = col[np.isfinite(col) & (col > 0)]
            if col.size == 0:
                v = max(float(best_row[p]), tiny)
                wlo, whi = v * 0.95, v * 1.05
            else:
                wlo, whi = col.min(), col.max()
            # clamp to allowed, pad if collapsed
            wlo = max(wlo, pr[p]["min"])
            whi = min(whi, pr[p]["max"])
            if whi <= wlo:
                wlo *= 0.95
                whi *= 1.05
            subset_ranges[p] = (wlo, whi)

        # global y span (from allowed)
        y_min = min(pr[p]["min"] for p in param_cols)
        y_max = max(pr[p]["max"] for p in param_cols)

        # ----------------------------- plot -------------------------------------
        fig, ax = plt.subplots(figsize=figsize, dpi=dpi)
        x = np.arange(len(param_cols), dtype=float)
        half = bar_width / 2.0

        for i, p in enumerate(param_cols):
            alo, ahi = pr[p]["min"], pr[p]["max"]
            wlo, whi = subset_ranges[p]
            best_val = max(float(best_row[p]), tiny)

            # grey allowed range
            ax.add_patch(
                patches.Rectangle((i - half, alo), bar_width, ahi - alo,
                                facecolor="lightgray", edgecolor="none", alpha=1.0)
            )
            # light-blue: best `percent`% by Rank
            ax.add_patch(
                patches.Rectangle((i - half, wlo), bar_width, whi - wlo,
                                facecolor="#7ec8ff", edgecolor="none", alpha=0.85)
            )
            # dark-blue horizontal line for the single best (lowest Rank)
            ax.hlines(best_val, i - bar_width * 0.35, i + bar_width * 0.35,
                    colors="#1f4ea8", linewidth=2.2)

        # y-axis formatting (log)
        ax.set_yscale("log")
        ax.set_ylim(y_min, y_max)
        ax.yaxis.set_major_locator(LogLocator(base=10.0, numticks=6))
        ax.yaxis.set_major_formatter(LogFormatterMathtext())
        ax.yaxis.set_minor_locator(LogLocator(base=10.0, subs=np.arange(2, 10)*0.1,
                                            numticks=12))
        ax.yaxis.set_minor_formatter(NullFormatter())
        ax.grid(True, which="both", axis="y", alpha=0.15)

        # x labels
        ax.set_xlim(-0.5, len(param_cols) - 0.5)
        ax.set_xticks(x)
        ax.set_xticklabels([parms_name_map.get(p, p) for p in param_cols],
                        rotation=35, ha="right")
        ax.tick_params(axis="x", labelsize=fontsize-2)
        ax.tick_params(axis="y", labelsize=fontsize-2)
        ax.set_ylabel("Parameter-Dependent Units", fontsize=fontsize)

        # legend
        legend_elems = [
            patches.Patch(facecolor="lightgray", edgecolor="none", label="Allowed range"),
            patches.Patch(facecolor="#7ec8ff", edgecolor="none",
                        label=f"Top {percent}% by Rank"),
            Line2D([0], [0], color="#1f4ea8", lw=2.2, label="Best value"),
        ]
        ax.legend(handles=legend_elems, loc="upper right", frameon=False,
                fontsize=fontsize-2)

        fig.tight_layout()
        fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
        print(f"Saved summary to: {save_path}")

    def plot_all_diffusion(self, figsize=(8, 7), fontsize=18, dpi=600):
        from matplotlib.patches import Patch
        from matplotlib.lines import Line2D

        mutants = ['WT', r'$\Delta$C2A', 'shRNA RIM2', r'$\Delta$C2B']

        # Data
        D_exp_pre   = [self.D_exp_pre,   self.D_exp_DC2A_pre,   self.D_exp_shRIM_pre,   self.D_exp_DC2B_pre]
        D_exp_post  = [self.D_exp_post,  self.D_exp_DC2A_post,  self.D_exp_shRIM_post,  self.D_exp_DC2B_post]
        D_model_pre  = [self.D_model_pre,  self.D_model_DC2A_pre,  self.D_model_shRIM_pre,  self.D_model_DC2B_pre]
        D_model_post = [self.D_model_post, self.D_model_DC2A_post, self.D_model_shRIM_post, self.D_model_DC2B_post]

        D_exp_pre_sem  = [self.D_exp_pre_sem,  self.D_exp_DC2A_pre_sem,  self.D_exp_shRIM_pre_sem,  self.D_exp_DC2B_pre_sem]
        D_exp_post_sem = [self.D_exp_post_sem, self.D_exp_DC2A_post_sem, self.D_exp_shRIM_post_sem, self.D_exp_DC2B_post_sem]

        n = len(mutants)

        # Layout: [Exp(NO), Exp(STIM)]   gap   [Model(NO), Model(STIM)]
        bar_width   = 0.18
        small_gap   = 0.10   # separation between Exp pair and Model pair
        group_gap   = 0.60   # separation between mutant groups
        group_width = 4*bar_width + small_gap

        centers = np.arange(n) * (group_width + group_gap)
        lefts = centers - group_width/2

        x_exp_no   = lefts + 0*bar_width
        x_exp_stim = lefts + 1*bar_width
        x_mod_no   = lefts + 2*bar_width + small_gap
        x_mod_stim = lefts + 3*bar_width + small_gap

        fig, ax = plt.subplots(figsize=figsize, dpi=dpi)

        # Colors and styles
        c_no, c_stim = 'black', 'red'
        hatch_model = '///'

        # EXP: solid fills (with error bars)
        ax.bar(x_exp_no,   D_exp_pre,  width=bar_width, yerr=D_exp_pre_sem,  capsize=4,
            color=c_no,   edgecolor='black', label='Exp (NO STIM)')
        ax.bar(x_exp_stim, D_exp_post, width=bar_width, yerr=D_exp_post_sem, capsize=4,
            color=c_stim, edgecolor='black', label='Exp (STIM)')

        # MODEL: hatched (use white fill + colored edge so the hatch stands out)
        ax.bar(x_mod_no,   D_model_pre,  width=bar_width,
            facecolor='white', edgecolor=c_no,   hatch=hatch_model, label='Model (NO STIM)')
        ax.bar(x_mod_stim, D_model_post, width=bar_width,
            facecolor='white', edgecolor=c_stim, hatch=hatch_model, label='Model (STIM)')

        # Axes/labels
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_xticks(centers)
        ax.set_xticklabels(mutants, fontsize=fontsize)
        ax.tick_params(axis='y', labelsize=fontsize * 0.8)
        ax.set_ylim(bottom=0)

        # Legend: show meaning of color and style separately (cleaner)
        color_handles = [
            Patch(facecolor=c_no,   edgecolor='black', label='NO STIM'),
            Patch(facecolor=c_stim, edgecolor='black', label='STIM')
        ]
        style_handles = [
            Patch(facecolor='black', edgecolor='black', label='Experiment'),
            Patch(facecolor='white', edgecolor='black', hatch=hatch_model, label='Model')
        ]

        # Move legends above the plot
        leg1 = ax.legend(
            handles=color_handles,
            fontsize=fontsize*0.75,
            frameon=False,
            loc='upper center',
            bbox_to_anchor=(0.35, 1.15)  # left group
        )
        ax.add_artist(leg1)

        ax.legend(
            handles=style_handles,
            fontsize=fontsize*0.75,
            frameon=False,
            loc='upper center',
            bbox_to_anchor=(0.65, 1.15)  # right group
        )

        # Adjust layout to fit
        plt.tight_layout(rect=[0, 0, 1, 0.95])

        # Cleanup
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        plt.show()

    def save_individual_solution_figures_combined(self, output_dir="../fig/individual_figures", best=100, totalTime=10.0, dt=0.1, figsize=(16, 20), dpi=300):
        os.makedirs(output_dir, exist_ok=True)
        self.filter_and_store_solutions(best=best, totalTime=totalTime, dt=dt)

        for idx, candidate_params in enumerate(self.filteredSolutions):
            print(f"Generating combined figure for solution #{idx}")

            fig, axes = plt.subplots(nrows=5, ncols=2, figsize=figsize, dpi=dpi)
            axes = axes.flatten()

            self._draw_plot_copies(candidate_params, axes[0])
            self._draw_plot_kinetic(candidate_params, axes[1])
            self._draw_plot_diffusion_comparison(candidate_params, axes[2])
            self._draw_plot_diffusion_dilute_only(candidate_params, axes[3])
            self._draw_plot_cluster_percentage_total(candidate_params, axes[4])
            self._draw_plot_cluster_percentage_2D(candidate_params, axes[5])
            self._draw_plot_DC2A(candidate_params, axes[6])
            self._draw_plot_shRIM(candidate_params, axes[7])
            self._draw_plot_lower_lipid_binding(candidate_params, axes[8])
            self._draw_plot_lower_conc_munc13(candidate_params, axes[9])

            fig.tight_layout()
            fig.savefig(os.path.join(output_dir, f"solution_{idx:03d}.png"), bbox_inches="tight")
            plt.close(fig)

    def _draw_plot_copies(self, candidate_params, ax):
        _, _, _, _, pre, post, preEq, postEq, _, _, _, _, _, _ = self.calculate_results(candidate_params)
        ax.plot(self.timePoints, pre / self.Atotal, label='NO STIM')
        ax.plot(self.timePoints, post / self.AtotalDense, label='STIM')
        ax.set_xlabel('Time (s)')
        ax.set_ylabel(r'Munc13$_{mem}$ (copies/$\mu$m$^2$)')
        ax.set_title("Membrane Munc13")
        ax.legend()

    def _draw_plot_kinetic(self, candidate_params, ax):
        _, _, preCluster, postCluster, _, _, preEq, postEq, _, _, _, _, _, _ = self.calculate_results(candidate_params)
        ax.plot(self.timePoints, preCluster, label='NO STIM')
        ax.plot(self.timePoints, postCluster, label='STIM')
        ax.set_xlabel('Time (s)')
        ax.set_ylabel('Munc13 in Cluster')
        ax.set_title("Clustered Munc13 Kinetics")
        ax.legend()

    def _draw_plot_diffusion_comparison(self, candidate_params, ax):
        _, _, _, _, d_pre, d_post = self.simulate(candidate_params)
        model_mean = [d_pre, d_post]
        model_sem = [0, 0]  # No SEM unless you're running replicates

        exp_vals = [self.D_exp_pre, self.D_exp_post]
        exp_sem = [self.D_exp_pre_sem, self.D_exp_post_sem]

        categories = ["NO STIM", "STIM"]
        x = np.arange(len(categories))
        width = 0.35
        fontsize = 12

        ax.bar(x - width/2, exp_vals, width, yerr=exp_sem, capsize=5,
            label="Experiment", color='red', alpha=0.8)
        ax.bar(x + width/2, model_mean, width, capsize=5,
            label="Model", color='blue', alpha=0.8)

        ax.set_xticks(x)
        ax.set_xticklabels(categories, fontsize=fontsize)
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_title("Average Diffusion: Sim vs Exp")
        ax.legend(fontsize=fontsize, loc='best')

    def _draw_plot_diffusion_dilute_only(self, candidate_params, ax):
        D1 = candidate_params[9]
        D2 = D1 / candidate_params[10]
        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate_params)
        D_dilute_pre = self.calc_diffusion_dilute(D1, D2, solutionPre)
        D_dilute_post = self.calc_diffusion_dilute(D1, D2, solutionPost)

        ax.bar([0, 1], [D_dilute_pre, D_dilute_post],
            tick_label=["NO STIM", "STIM"], color='skyblue')
        ax.set_ylabel("Dilute Diffusion (m/s)")
        ax.set_title("Dilute Diffusion")

    def _draw_plot_cluster_percentage_total(self, candidate_params, ax):
        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate_params)
        perc_cluster_pre = self.calc_percentages_cluster(solutionPre)
        perc_cluster_post = self.calc_percentages_cluster(solutionPost)

        ax.bar([0, 1], [perc_cluster_pre, perc_cluster_post],
            tick_label=["NO STIM", "STIM"], color='salmon')
        ax.set_ylabel("Clustered % (Total)")
        ax.set_title("Total Clustered Percentage")

    def _draw_plot_cluster_percentage_2D(self, candidate_params, ax):
        solutionPre, solutionPost, _, _, _, _ = self.simulate(candidate_params)
        _, perc_cluster_pre_2D = self.calc_3D_2D_percentages_cluster(solutionPre)
        _, perc_cluster_post_2D = self.calc_3D_2D_percentages_cluster(solutionPost)

        ax.bar([0, 1], [perc_cluster_pre_2D, perc_cluster_post_2D],
            tick_label=["NO STIM", "STIM"], color='lightgreen')
        ax.set_ylabel("Clustered % (2D only)")
        ax.set_title("2D Clustered Percentage")

    def _draw_plot_DC2A(self, candidate_params, ax):
        candidate = list(candidate_params)
        c3 = candidate[3]
        candidate[3] = 0
        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        candidate[3] = c3

        model_mean = [d_pre, d_post]
        model_sem = [0, 0]

        exp_vals = [self.D_exp_DC2A_pre, self.D_exp_DC2A_post]
        exp_sem = [self.D_exp_DC2A_pre_sem, self.D_exp_DC2A_post_sem]

        categories = ["NO STIM", "STIM"]
        x = np.arange(len(categories))
        width = 0.35
        fontsize = 12

        ax.bar(x - width/2, exp_vals, width, yerr=exp_sem, capsize=5,
            label="Experiment", color='red', alpha=0.8)
        ax.bar(x + width/2, model_mean, width, capsize=5,
            label="Model", color='purple', alpha=0.8)

        ax.set_xticks(x)
        ax.set_xticklabels(categories, fontsize=fontsize)
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_title("DC2A Diffusion")
        ax.legend(fontsize=fontsize, loc='best')

    def _draw_plot_shRIM(self, candidate_params, ax):
        candidate = list(candidate_params)
        c3 = candidate[3]
        candidate[3] *= 2
        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        candidate[3] = c3

        model_mean = [d_pre, d_post]
        model_sem = [0, 0]

        exp_vals = [self.D_exp_shRIM_pre, self.D_exp_shRIM_post]
        exp_sem = [self.D_exp_shRIM_pre_sem, self.D_exp_shRIM_post_sem]

        categories = ["NO STIM", "STIM"]
        x = np.arange(len(categories))
        width = 0.35
        fontsize = 12

        ax.bar(x - width/2, exp_vals, width, yerr=exp_sem, capsize=5,
            label="Experiment", color='red', alpha=0.8)
        ax.bar(x + width/2, model_mean, width, capsize=5,
            label="Model", color='orange', alpha=0.8)

        ax.set_xticks(x)
        ax.set_xticklabels(categories, fontsize=fontsize)
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_title("shRIM Diffusion")
        ax.legend(fontsize=fontsize, loc='best')

    def _draw_plot_lower_lipid_binding(self, candidate_params, ax):
        candidate = list(candidate_params)
        c0 = candidate[0]
        candidate[0] *= 0.5
        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        candidate[0] = c0

        model_mean = [d_pre, d_post]
        model_sem = [0, 0]

        if d_pre > d_post:
            print("lower lipid binding d_pre > d_post")
            print(candidate)

        exp_vals = [self.D_exp_DC2B_pre, self.D_exp_DC2B_post]
        exp_sem = [self.D_exp_DC2B_pre_sem, self.D_exp_DC2B_post_sem]

        categories = ["NO STIM", "STIM"]
        x = np.arange(len(categories))
        width = 0.35
        fontsize = 12

        ax.bar(x - width/2, exp_vals, width, yerr=exp_sem, capsize=5,
            label="Experiment", color='red', alpha=0.8)
        ax.bar(x + width/2, model_mean, width, capsize=5,
            label="Model", color='green', alpha=0.8)

        ax.set_xticks(x)
        ax.set_xticklabels(categories, fontsize=fontsize)
        ax.set_ylabel(r"$\mathrm{Average\ Diffusion}\ (\mu\mathrm{m}^2/\mathrm{s})$", fontsize=fontsize)
        ax.set_title("Lower Lipid Binding (DC2B)")
        ax.legend(fontsize=fontsize, loc='best')

    def _draw_plot_lower_conc_munc13(self, candidate_params, ax):
        candidate = list(candidate_params)
        c7 = candidate[7]
        candidate[7] *= 0.1  # reduce Munc13 initial conc
        _, _, _, _, d_pre, d_post = self.simulate(candidate)
        ax.bar([0, 1], [d_pre, d_post], tick_label=["NO STIM", "STIM"], color='gray')
        ax.set_title("Lower Munc13 Concentration")
        candidate[7] = c7


class Solver:
    def __init__(self, model, populationSize=100, NGEN=100):
        """
        Sets up a DEAP-based Genetic Algorithm to optimize parameters for Munc13 model.
        :param model: A Munc13 model instance
        :param populationSize: number of individuals in each GA generation
        :param NGEN: number of generations
        """
        self.model = model
        self.populationSize = populationSize
        self.NGEN = NGEN
        self.indpb = 0.05  # Probability of mutation per gene

        # Create DEAP classes
        creator.create("FitnessMax", base.Fitness, weights=(1.0,))
        creator.create("Candidate", list, fitness=creator.FitnessMax)

        self.toolbox = base.Toolbox()
        # Register "gene generator"
        self.toolbox.register("candidate", self.generateCandidate)
        # Define how to build a population of individuals
        self.toolbox.register("population", tools.initRepeat, list, self.toolbox.candidate)
        # Genetic operators
        self.toolbox.register("mate", tools.cxTwoPoint)
        self.toolbox.register("mutate", self.mutateCandidate, indpb=self.indpb, mult=1.0)
        self.toolbox.register("select", tools.selRoulette)

        # Register the main evaluation function with DEAP
        # (We only pick one from model.modes if you have multiple)
        self.toolbox.register("evaluate", self.model.eval_both)

        # Create a multiprocessing pool for parallel fitness evaluation
        self.pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())
        self.toolbox.register("map", self.pool.map)

    def generateCandidate(self):
        """
        Generate one random candidate solution by sampling each parameter
        in log10 space between [log10(min), log10(max)].
        """
        candidate = []
        for i in range(self.model.n_params):
            param_name = self.model.params_to_optimize[i]
            low = self.model.parameter_ranges[param_name]["min"]
            high = self.model.parameter_ranges[param_name]["max"]
            logval = np.random.uniform(math.log10(low), math.log10(high))
            candidate.append(10 ** logval)
        return creator.Candidate(candidate)

    def mutateCandidate(self, candidate, indpb, mult):
        """
        Mutates each gene with probability (1 - indpb). 
        The new value is scaled by 'rnd2' in [1-mult, 1+mult].
        Clamps to min/max if out of range.
        """
        for idx, val in enumerate(candidate):
            if np.random.rand() >= indpb:
                scale_factor = np.random.uniform(1 - mult, 1 + mult)
                candidate[idx] = val * scale_factor

                # Clamp to [min, max]
                param_name = self.model.params_to_optimize[idx]
                min_val = self.model.parameter_ranges[param_name]["min"]
                max_val = self.model.parameter_ranges[param_name]["max"]
                candidate[idx] = max(min_val, min(candidate[idx], max_val))
        return (candidate,)

    def findNominalValues(self):
        """
        Main GA loop: 
          - create initial population
          - run for NGEN generations
          - track any 'viable' solutions above the threshold
        Returns final sets of (viablePoints, viableFitness, twoDVals).
        """
        # Initialize population
        population = self.toolbox.population(n=self.populationSize)

        # Will store all viable solutions across generations
        all_viable_points = []
        all_viable_fitness = []

        # GA main loop
        for gen in range(self.NGEN):
            # Variation (recombination+mutation)
            offspring = algorithms.varAnd(population, self.toolbox, cxpb=0.8, mutpb=0.2) #0.8, 0.02
            # Evaluate in parallel
            fits = list(self.toolbox.map(self.toolbox.evaluate, offspring))

            for fit_val, ind in zip(fits, offspring):
                cost, = fit_val
                ind.fitness.values = (cost,)

                # Check viability
                if cost >= self.model.threshold:
                    # Store if not already in the set
                    if ind not in all_viable_points:
                        all_viable_points.append(ind[:])  # store a copy
                        all_viable_fitness.append([cost])

            # Selection step
            population = self.toolbox.select(offspring, k=len(population))

            if gen % 20 == 0:
                print(f"=== Generation {gen} ===")
                print(f"Number of viable points so far: {len(all_viable_points)}")

        return (all_viable_points, all_viable_fitness)

    def write_sortedParms(self, viablePoints, viableFitness):
        """
        Sort viable solutions by fitness, write the top solutions to a file.
        """
        outfile = "../data/optimizedParms.txt"
        print(f"Writing results to {outfile}")

        # Prepare arrays for sorting
        fit_values = [vf[0] for vf in viableFitness]
        neg_fit_values = [-v for v in fit_values]

        # Sort indices by negative fitness (so best->worst)
        idx_sorted = np.argsort(neg_fit_values)

        with open(outfile, "w") as f:
            # CSV header
            header = (
                "Rank, Fitness, kfsr, krsr_nostim, krsr_stim, kfmm, krmm, kfc_nostim, kfc_stim, S0, R0, D1, D1_over_D2, X\n"
            )
            f.write(header)

            for rank, idx in enumerate(idx_sorted):
                fitness_val = fit_values[idx]
                params = viablePoints[idx]

                # Unpack your parameters in the known order
                kfsr = params[0]
                krsr_nostim = params[1]
                krsr_stim = params[2]
                kfmm = params[3]
                krmm = params[4]
                kfc_nostim = params[5]
                kfc_stim = params[6]
                S0 = params[7]
                R0 = params[8]
                D1 = params[9]
                D1_over_D2 = params[10]
                X = params[11]

                # Write a line per solution
                f.write(
                    f"{rank}, {fitness_val:.4f}, "
                    f"{kfsr:.5g}, {krsr_nostim:.5g}, {krsr_stim:.5g}, {kfmm:.5g}, "
                    f"{krmm:.5g}, {kfc_nostim:.5g}, {kfc_stim:.5g}, {S0:.5g}, "
                    f"{R0:.5g}, {D1:.5g}, {D1_over_D2:.5g}, {X:.5g}\n"
                )

        print("Finished writing parameter file.")

    def run(self):
        """
        A convenience method to run the entire pipeline:
          1) findNominalValues (GA)
          2) sort & write results
        """
        viablePoints, viableFitness = self.findNominalValues()
        self.write_sortedParms(viablePoints, viableFitness)

        # IMPORTANT: close the pool to avoid zombie processes
        self.pool.close()
        self.pool.join()

        print("Done with all GA generations and file writing.")
        return viablePoints, viableFitness
    

if __name__ == "__main__":
    start_time = time.time()
    # Parameter definitions
    parameter_ranges = {
        "kfsr":      {"min": 0.001, "max": 10},   # kfSR
        "krsr_nostim":      {"min": 0.1,   "max": 1000}, # krSR_nostim
        "krsr_stim":       {"min": 0.1,   "max": 1000}, # krSR_stim
        "kfmm":      {"min": 0.001, "max": 10},   # kfMM
        "krmm":      {"min": 0.01,   "max": 100}, # krMM
        "kfc_nostim":      {"min": 0.001, "max": 10},   # kfc_nostim
        "kfc_stim":      {"min": 0.001, "max": 10},   # kfc_stim
        "S0":        {"min": 0.01, "max": 10},   # S0
        "R0":        {"min": 100, "max": 500},   # R0
        "D1":        {"min": 0.05,   "max": 5}, # D1
        "D1_over_D2":        {"min": 1.5,   "max": 5}, # D2
        "X":        {"min": 10,   "max": 10}, # X
    }

    # Order in which the solver will read parameters from a candidate
    params_to_optimize = np.array([
        "kfsr","krsr_nostim","krsr_stim","kfmm","krmm","kfc_nostim","kfc_stim","S0","R0","D1","D1_over_D2","X"
    ])

    # GA settings
    popSize = 500
    nGen = 500

    # Instantiate the model and solver
    model = Munc13(parameter_ranges, params_to_optimize, t_max_pre=50)
    solver = Solver(model, populationSize=popSize, NGEN=nGen)

    # Run the GA
    viablePoints, viableFitness = solver.run()

    # Print top solution info
    if len(viableFitness) > 0:
        best_fit = max(viableFitness, key=lambda x: x[0])
        print(f"Best fitness from the run: {best_fit[0]}")
        print("Best parameters:", viablePoints[viableFitness.index(best_fit)])
    else:
        print("No viable solutions found.")
    end_time = time.time()
    elapsed_time = end_time - start_time
    elapsed_time_minutes = elapsed_time / 60
    print(f"Total execution time: {elapsed_time_minutes:.2f} minutes")